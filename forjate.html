<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FORJATE</title>
  <style>
    .topnav{display:none!important;} .stage{padding-top:0!important;} iframe{height:100vh!important;}
    :root{
      --bg:#b7d7f0;
      --hdr:#cfe3f6;
      --grid:#000;
      --white:#fff;
      --btn:#2b6cb0;
      --btn2:#1e5a96;
      --focus:#2563eb;
      --muted:#334155;
      --cell:#e8e4f6; /* light purple, like screenshot */
      --head:#c9d7ea;
      --head2:#bcd0e6;
      --pill:#ffffffcc;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family: Calibri, Arial, sans-serif; background:var(--bg); color:#111; min-height:100vh; }

    .topbar{ display:flex; align-items:center; justify-content:flex-end; gap:10px; padding:6px 10px; flex-wrap:wrap; }
    .btnMenu{
      margin-right:auto; border:0; background: rgba(255,255,255,.85);
      color:#0f172a; font-weight:700; padding:6px 10px; border-radius:3px;
      cursor:pointer; box-shadow:0 1px 0 rgba(0,0,0,.12);
    }
    .btnMenu:hover{ background:#fff; }
    .btn{
      border:0; background:var(--btn); color:#fff; font-weight:700;
      padding:6px 10px; border-radius:3px; cursor:pointer;
      box-shadow:0 1px 0 rgba(0,0,0,.15);
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{ background:var(--btn2); }
    .btn.secondary{ background:#ffffffcc; color:#0f172a; }
    .btn.secondary:hover{ background:#fff; }

    .plusCircle{
      width:18px; height:18px; border-radius:999px; background:#fff; color:var(--btn);
      display:inline-flex; align-items:center; justify-content:center; font-weight:900; line-height:1;
    }

    .pills{ display:flex; align-items:center; gap:10px; padding:0 10px 6px; flex-wrap:wrap; }
    .pill{ background:var(--pill); border:1px solid rgba(0,0,0,.25); border-radius:999px; padding:4px 10px; font-size:12px; display:inline-flex; gap:8px; align-items:center; }
    .pill strong{ font-weight:800; }
    .pill.bad{ border-color:#b91c1c; color:#b91c1c; background:#fff; }
    .pill.ok{ border-color:#15803d; color:#15803d; background:#fff; }
    .pill.warn{ border-color:#b45309; color:#b45309; background:#fff; }

    .wrap{ padding:0 10px 14px; }
    .sheet{ background:transparent; border-radius:6px; }
    .tableWrap{ overflow:auto; border:1px solid rgba(0,0,0,.35); background:#d7e8f8; }

    table{ border-collapse:collapse; width:max-content; min-width:100%; }
    thead th{
      position:sticky; top:0; z-index:5;
      background:linear-gradient(#d4dfef, var(--head));
      border:1px solid var(--grid);
      padding:6px 8px;
      font-size:12px;
      text-align:center;
      white-space:nowrap;
    }
    thead th .flt{ float:right; margin-left:6px; width:0; height:0; border-left:4px solid transparent; border-right:4px solid transparent; border-top:6px solid rgba(0,0,0,.6); opacity:.7; }

    tbody td{ border:1px solid var(--grid); background:var(--cell); padding:0; }

    .cellInp, .cellSel{
      width:100%; border:0; outline:none; padding:4px 6px; background:transparent;
      font-family:inherit; font-size:12px; color:#111;
    }
    .cellInp:focus, .cellSel:focus{ outline:2px solid var(--focus); outline-offset:-2px; background:rgba(255,255,255,.45); }

    .cellText{ padding:4px 6px; font-size:12px; white-space:nowrap; }
    .center{ text-align:center; }
    .right{ text-align:right; }
    .red{ color:#b91c1c; font-weight:700; }

    .floatingAdd{
      position:fixed; right:18px; top:10px; z-index:50;
      display:none; /* not needed because we already have add button */
    }

    /* Modal */
    .modalBack{ position:fixed; inset:0; background:rgba(2,6,23,.45); display:none; align-items:center; justify-content:center; padding:18px; z-index:100; }
    .modal{ width:min(980px, 100%); background:#fff; border-radius:10px; box-shadow:0 20px 60px rgba(0,0,0,.35); overflow:hidden; }
    .modalHead{ background:linear-gradient(var(--hdr), #e8f2ff); padding:10px 12px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid rgba(0,0,0,.15); }
    .modalHead h3{ margin:0; font-size:14px; }
    .modalBody{ padding:12px; }
    .grid{ display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap:10px; }
    .field{ display:flex; flex-direction:column; gap:4px; }
    .field label{ font-size:11px; font-weight:800; color:#0f172a; }
    .field input, .field select{ padding:7px 8px; border:1px solid rgba(0,0,0,.25); border-radius:6px; font-family:inherit; font-size:12px; }
    .field input:focus, .field select:focus{ outline:2px solid var(--focus); border-color:transparent; }
    .note{ font-size:11px; color:#475569; margin-top:8px; }
    .modalFoot{ padding:10px 12px; display:flex; justify-content:flex-end; gap:10px; border-top:1px solid rgba(0,0,0,.15); background:#f8fafc; }

    @media (max-width: 920px){ .grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 520px){ .grid{ grid-template-columns: 1fr; } }

    /* Disabled overlay */
    .lock{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(2,6,23,.55); z-index:200; padding:20px; }
    .lockBox{ background:#fff; border-radius:12px; padding:16px 16px; width:min(560px, 100%); box-shadow:0 20px 60px rgba(0,0,0,.4); }
    .lockBox h2{ margin:0 0 6px; font-size:16px; }
    .lockBox p{ margin:0 0 10px; color:#334155; font-size:13px; }
  </style>
</head>
<body>

  <div class="topbar">
    <button class="btnMenu" id="btnBack">← Dashboard</button>

    <button class="btn secondary" id="btnExportXlsx">⬇ Export Excel</button>
    <button class="btn secondary" id="btnImportXlsx">⬆ Import Excel</button>
    <button class="btn secondary" id="btnExportJson">⬇ Export JSON</button>
    <button class="btn secondary" id="btnReset">Reset</button>

    <button class="btn" id="btnAdd"><span class="plusCircle">+</span> Adaugă</button>
  </div>

  <div class="pills">
    <div class="pill" id="rowsPill"><strong>0</strong> rânduri</div>
    <div class="pill" id="autosavePill">autosave: –</div>
    <div class="pill" id="roleBadge" style="display:none;"><span id="roleDot" style="width:8px;height:8px;border-radius:999px;background:#111;display:inline-block;"></span><span id="roleText"></span></div>
    <div class="pill warn" id="cloudBadge" style="display:none;">Cloud: …</div>
  </div>

  <div class="wrap">
    <div class="sheet">
      <div class="tableWrap">
        <table id="tbl">
          <thead><tr id="hdr"></tr></thead>
          <tbody id="body"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- datalists -->
  <datalist id="dlCiocane"></datalist>
  <datalist id="dlRepere"></datalist>

  <!-- modal add -->
  <div class="modalBack" id="modalBack">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHead">
        <h3>Adaugă FORJATE (doar câmpurile de intrare — restul se calculează automat)</h3>
        <button class="btn secondary" id="btnClose">✕</button>
      </div>
      <div class="modalBody">
        <div class="grid">
          <div class="field"><label>An</label><input id="f_an" inputmode="numeric" placeholder="2026"></div>
          <div class="field"><label>Lună</label>
            <select id="f_luna"></select>
          </div>
          <div class="field"><label>Data</label><input id="f_data" placeholder="dd.mm.yyyy"></div>
          <div class="field"><label>Schimbul</label>
            <select id="f_schimb"><option value="1">1</option><option value="2">2</option><option value="3">3</option></select>
          </div>

          <div class="field"><label>Ciocan (linie forjă)</label><input id="f_ciocan" list="dlCiocane" placeholder="ex: 3 T BR"></div>
          <div class="field"><label>Reper</label><input id="f_reper" list="dlRepere" placeholder="ex: 248-2307"></div>
          <div class="field"><label>Dimensiune oțel (Ø)</label><input id="f_diam" placeholder="ex: 71"></div>
          <div class="field"><label>Calitate oțel</label><input id="f_cal" placeholder="ex: 1E-1287/15B34"></div>

          <div class="field"><label>Marcaj matriță</label><input id="f_marcaj" placeholder="ex: RR"></div>
          <div class="field"><label>Cod CAT DK</label><input id="f_cat_dk" placeholder="opțional"></div>
          <div class="field"><label>Cod CAT MARC</label><input id="f_cat_marc" placeholder="opțional"></div>
          <div class="field"><label>Denumire portmatriță</label>
            <select id="f_port">
              <option value=""></option>
              <option>1 PMF</option><option>2 PMF</option><option>3 PMF</option><option>4 PMF</option>
            </select>
          </div>

          <div class="field"><label>Matriță SUPERIOARĂ</label><input id="f_sup" placeholder="ex: D"></div>
          <div class="field"><label>Înălțime MF SUP (mm)</label><input id="f_sup_h" inputmode="numeric" placeholder="ex: 305"></div>
          <div class="field"><label>Matriță INFERIOARĂ</label><input id="f_inf" placeholder="ex: E"></div>
          <div class="field"><label>Înălțime MF INF (mm)</label><input id="f_inf_h" inputmode="numeric" placeholder="ex: 280"></div>

          <div class="field"><label>Buc realizate</label><input id="f_buc" inputmode="numeric" placeholder="ex: 1200"></div>
          <div class="field"><label>Rebut</label><input id="f_rebut" inputmode="numeric" placeholder="ex: 1"></div>
          <div class="field"><label>Tact (sec.)</label><input id="f_tact" inputmode="numeric" placeholder="ex: 17"></div>
          <div class="field"><label>Încălzire SDV (min)</label><input id="f_inc" inputmode="numeric" placeholder="ex: 45"></div>

          <div class="field"><label>Schimbare reper (min)</label><input id="f_sch" inputmode="numeric" placeholder="ex: 60"></div>
          <div class="field"><label>Reglaj (min)</label><input id="f_reg" inputmode="numeric" placeholder="ex: 20"></div>
          <div class="field"><label>Opriri neplanificate (min)</label><input id="f_opr" inputmode="numeric" placeholder="ex: 15"></div>
          <div class="field"><label>Pauză de masă (min)</label><input id="f_pauza" inputmode="numeric" placeholder="ex: 30"></div>
        </div>

        <div class="note">
          Reguli de calcul (ca în poză): <b>Timp disponibil</b> = 480 − (Schimbare reper + Reglaj + Opriri + Încălzire SDV + Pauză). 
          <b>Disponibilitate</b> = TimpDispon / 480. 
          <b>Planificat</b> = (TimpDispon×60) / Tact. 
          <b>Performanță</b> = (BucRealizate×Tact) / (TimpDispon×60). 
          <b>Calitate</b> = (BucRealizate−Rebut) / BucRealizate. 
          <b>OEE</b> = Disponibilitate×Performanță×Calitate.
        </div>
      </div>
      <div class="modalFoot">
        <button class="btn secondary" id="btnCancel">Renunță</button>
        <button class="btn" id="btnSave">Salvează rând</button>
      </div>
    </div>
  </div>

  <div class="lock" id="lock">
    <div class="lockBox">
      <h2>Nu ești autentificat / Cloud indisponibil</h2>
      <p>Pagina FORJATE rulează doar conectată la Supabase (fără mod local). Revino în Dashboard și autentifică-te.</p>
      <button class="btn" id="btnToDash">Înapoi la Dashboard</button>
    </div>
  </div>

  <!-- Supabase JS -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- XLSX for Excel import/export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
/* ===============================
   CONFIG
   =============================== */
const SUPABASE_URL = "https://rhjcnydkdhjzazygybcc.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJoamNueWRrZGhqemF6eWd5YmNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE4ODEzMzYsImV4cCI6MjA4NzQ1NzMzNn0.ompOZWqnFGsnOQzPiAv2QBwuaNiKtnz5PciRwCWh0Hk";

const DOC_TABLE = 'rf_documents';
const DOC_KEY = 'forjate';

const LS_KEY_DATA = 'FORJATE_autosave_v1';
const LS_KEY_HELPERS = 'RF_HELPERS_v1';

const MONTHS = [
  'ianuarie','februarie','martie','aprilie','mai','iunie','iulie','august','septembrie','octombrie','noiembrie','decembrie'
];

/* ===============================
   STATE
   =============================== */
const STATE = {
  version: 1,
  updated_at: null,
  rows: []
};
let HELPERS = null;

let __DIRTY = false;
let __HAS_LOCAL_PENDING = false;
let __LAST_LOCAL_CHANGE = 0;

/* ===============================
   ELEMENTS
   =============================== */
const hdr = document.getElementById('hdr');
const body = document.getElementById('body');
const rowsPill = document.getElementById('rowsPill');
const autosavePill = document.getElementById('autosavePill');
const cloudBadge = document.getElementById('cloudBadge');
const roleBadge = document.getElementById('roleBadge');
const roleText = document.getElementById('roleText');
const roleDot = document.getElementById('roleDot');
const lock = document.getElementById('lock');

const modalBack = document.getElementById('modalBack');

/* ===============================
   UTIL
   =============================== */
function nowIso(){ return new Date().toISOString(); }
function roInt(n){
  const x = Number(n);
  if(!Number.isFinite(x)) return '';
  return Math.round(x).toLocaleString('ro-RO');
}
function roNum(n, decimals){
  const x = Number(n);
  if(!Number.isFinite(x)) return '';
  const d = (decimals==null) ? 0 : decimals;
  return x.toLocaleString('ro-RO', { minimumFractionDigits:d, maximumFractionDigits:d });
}
function pct(n){
  const x = Number(n);
  if(!Number.isFinite(x)) return '';
  return (x*100).toLocaleString('ro-RO', { minimumFractionDigits:2, maximumFractionDigits:2 }) + '%';
}
function mins(v, red){
  const x = Number(v);
  if(!Number.isFinite(x) || x<=0) return '';
  return roInt(x) + ' Min.';
}
function toNum(v){
  if(v===null || v===undefined) return 0;
  if(typeof v === 'number') return Number.isFinite(v) ? v : 0;
  let s = String(v).trim().replace(/\s+/g,'');
  if(!s) return 0;
  // keep digits, separators, minus; strip units like "Min." / "Sec." / "ø"
  s = s.replace(/[^0-9,\.\-]/g,'');
  if(!s) return 0;

  // Romanian parsing:
  // - if comma exists => decimal separator, dots are thousands
  // - else if dots look like thousands grouping (1-3 digits then .### repeats) => remove dots
  // - else dot is decimal
  if(s.includes(',')){
    s = s.replace(/\./g,'').replace(',', '.');
  } else if(s.includes('.')){
    if(/^\-?\d{1,3}(\.\d{3})+$/.test(s)){
      s = s.replace(/\./g,'');
    }
    // else: dot remains decimal
  }

  const n = Number(s);
  return Number.isFinite(n) ? n : 0;
}
function toStr(v){ return (v===null||v===undefined) ? '' : String(v); }
function upper(v){ return toStr(v).trim().toUpperCase(); }

function uuid(){
  try{ return crypto.randomUUID(); }catch(_e){ return 'id_' + Math.random().toString(16).slice(2) + '_' + Date.now(); }
}

function markDirty(){
  __DIRTY = true;
  __HAS_LOCAL_PENDING = true;
  __LAST_LOCAL_CHANGE = Date.now();
  scheduleAutosave();
  try{ window.notifyDataChanged && window.notifyDataChanged(); }catch(_e){}
}

let autosaveTimer = null;
function setAutosavePill(txt, cls){
  autosavePill.textContent = txt;
  autosavePill.classList.remove('ok','bad','warn');
  if(cls) autosavePill.classList.add(cls);
}
function scheduleAutosave(){
  if(autosaveTimer) clearTimeout(autosaveTimer);
  setAutosavePill('autosave: …', 'warn');
  autosaveTimer = setTimeout(()=>{
    try{
      STATE.updated_at = nowIso();
      localStorage.setItem(LS_KEY_DATA, JSON.stringify({ version: STATE.version, updated_at: STATE.updated_at, rows: STATE.rows }));
      setAutosavePill('autosave: saved', 'ok');
      __DIRTY = false;
    }catch(e){
      console.warn(e);
      setAutosavePill('autosave: error', 'bad');
    }
  }, 250);
}

function loadLocal(){
  try{
    const raw = localStorage.getItem(LS_KEY_DATA);
    if(!raw) return;
    const payload = JSON.parse(raw);
    if(payload && Array.isArray(payload.rows)){
      STATE.rows = payload.rows;
      STATE.updated_at = payload.updated_at || null;
    }
  }catch(_e){}
}

function loadHelpersLocal(){
  try{
    const raw = localStorage.getItem(LS_KEY_HELPERS);
    HELPERS = raw ? JSON.parse(raw) : null;
  }catch(_e){ HELPERS = null; }
}

function helperMaps(){
  const h = HELPERS || {};
  const repD = new Map();
  (h.repere_debitare||[]).forEach(r=>{
    const k = upper(r.REPER_DEBITARE);
    if(k) repD.set(k, r);
  });

  const repF = new Map();
  (h.repere_forjate||[]).forEach(r=>{
    const k = upper(r.REPER_FORJAT || r.REPER || r.REPER_FORJATE || r.REPER_DEBITARE);
    if(!k) return;
    repF.set(k, r);
  });

  const tact = new Map();
  (h.tacturi||[]).forEach(r=>{
    const k1 = upper(r.CIOCAN || r.UTILAJ || r.LINIE || '');
    const k2 = upper(r.REPER || r.REPER_FORJAT || r.REPER_DEBITARE || '');
    const key = (k1 && k2) ? (k1+'|'+k2) : (k2 ? ('*|'+k2) : '');
    if(!key) return;
    const v = toNum(r.TACT || r.TACT_SEC || r.TACT_S || r.SEC || r.TACT_SECONDS);
    if(v>0) tact.set(key, v);
  });

  return { repD, repF, tact };
}

function ensureHelperFields(row){
  const { repD, repF, tact } = helperMaps();
  const rk = upper(row.reper);
  const ck = upper(row.ciocan);

  if(rk){
    const d = repD.get(rk);
    if(d){
      if(!toStr(row.diametru).trim()) {
        const v = (d.DIAMETRU_OTEL ?? '');
        row.diametru = (v!=='' && v!==null && v!==undefined) ? ('ø ' + String(v).trim().replace(/^ø\s*/i,'')) : '';
      }
      if(!toStr(row.calitate).trim()) row.calitate = d.CALITATE_OTEL ?? '';
      if(!toNum(row.kg_buc_debitat)) row.kg_buc_debitat = toNum(d.KG_BUC_DEBITAT);
    }

    const f = repF.get(rk);
    if(f){
      if(!toNum(row.kg_buc_forjat)) row.kg_buc_forjat = toNum(f.KG_BUC_FORJAT || f.KG_BUC || f.KG_BUC_FORJ);
    }

    // tact by ciocan|reper OR *|reper
    if(!toNum(row.tact_sec)){
      const t = tact.get(ck+'|'+rk) || tact.get('*|'+rk) || 0;
      if(t>0) row.tact_sec = t;
    }
  }
}

function recalcRow(row){
  ensureHelperFields(row);

  const buc = toNum(row.buc_realizate);
  const rebut = toNum(row.rebut);
  const tactSec = toNum(row.tact_sec);

  const sch = toNum(row.schimbare_reper_min);
  const reg = toNum(row.reglaj_min);
  const opr = toNum(row.opriri_min);
  const inc = toNum(row.incalzire_sdv_min);
  const pauza = toNum(row.pauza_masa_min);

  const downtime = sch + reg + opr + inc + pauza;
  const timpDispon = Math.max(0, 480 - downtime);

  row.timp_dispon_min = timpDispon;
  row.disponibilitate = (480>0) ? (timpDispon / 480) : 0;

  row.planificat = (tactSec>0) ? Math.floor((timpDispon * 60) / tactSec) : 0;
  row.performanta = (timpDispon>0 && tactSec>0) ? ((buc * tactSec) / (timpDispon * 60)) : 0;
  row.procent_calitate = (buc>0) ? ((buc - rebut) / buc) : 0;
  row.oee = row.disponibilitate * row.performanta * row.procent_calitate;

  const kgDeb = toNum(row.kg_buc_debitat);
  const kgForj = toNum(row.kg_buc_forjat);

  row.kg_semif_debit = (buc>0 && kgDeb>0) ? (buc * kgDeb) : 0;
  row.kg_forj = (buc>0 && kgForj>0) ? (buc * kgForj) : 0;

  // combinare matrite
  const sup = upper(row.matrita_sup);
  const inf = upper(row.matrita_inf);
  row.combinare_matrite = (sup && inf) ? (sup + '+' + inf) : '';

  return row;
}

function recalcAll(){
  STATE.rows.forEach(recalcRow);
}

/* ===============================
   TABLE DEF (like screenshot)
   =============================== */
const COLS = [
  { key:'an', label:'ANUL', w:60, type:'num', center:true },
  { key:'luna', label:'LUNA', w:92, type:'month' },
  { key:'data', label:'DATA', w:96 },
  { key:'schimb', label:'SCHIMBUL', w:64, type:'shift', center:true },
  { key:'ciocan', label:'CIOCAN', w:84, type:'ciocan' },
  { key:'reper', label:'REPER', w:88, type:'reper' },
  { key:'diametru', label:'Dimensiune\noțel', w:78, type:'diam', center:true },
  { key:'calitate', label:'CALITATE OȚEL', w:120 },
  { key:'marcaj', label:'Marcaj\nMatri', w:72, center:true },
  { key:'cod_cat_dk', label:'COD CAT\nDK', w:74, center:true },
  { key:'cod_cat_marc', label:'COD CAT\nMARC', w:80, center:true },
  { key:'matrita_sup', label:'MATRIȚA\nSUPERIOARĂ', w:78, center:true },
  { key:'inaltime_sup', label:'Înălțime\nMF SUP', w:84, type:'num', center:true },
  { key:'matrita_inf', label:'MATRIȚA\nINFERIOARĂ', w:78, center:true },
  { key:'inaltime_inf', label:'Înălțime\nMF INF', w:84, type:'num', center:true },
  { key:'combinare_matrite', label:'Combinare\nmatrițe', w:92, calc:true, center:true },
  { key:'portmatrita', label:'Denumire\nPortmatriță', w:104, type:'port' },
  { key:'buc_realizate', label:'BUC\nRealizate', w:84, type:'num', center:true, showZero:true },
  { key:'rebut', label:'Rebut', w:54, type:'num', center:true, redIfPositive:true, showZero:true },
  { key:'planificat', label:'Planificat', w:76, calc:true, right:true, fmt:'int' },
  { key:'kg_semif_debit', label:'KG SEMIF.\nDEBIT', w:90, calc:true, right:true, fmt:'kg' },
  { key:'kg_forj', label:'KG\nFORJ', w:72, calc:true, right:true, fmt:'kg' },
  { key:'tact_sec', label:'Tact', w:58, type:'num', center:true, fmt:'sec', showZero:false },
  { key:'schimbare_reper_min', label:'Schimbare\nreper [Min]', w:106, type:'num', center:true, fmt:'min', redIfPositive:true },
  { key:'reglaj_min', label:'Reglaj\n[Min]', w:80, type:'num', center:true, fmt:'min', redIfPositive:true },
  { key:'opriri_min', label:'Opriri\nNeplanif. [Min]', w:118, type:'num', center:true, fmt:'min', redIfPositive:true },
  { key:'incalzire_sdv_min', label:'Încălzire SDV\n[Min]', w:110, type:'num', center:true, fmt:'min' },
  { key:'pauza_masa_min', label:'Pauză de masă\n[Min]', w:110, type:'num', center:true, fmt:'min' },
  { key:'timp_dispon_min', label:'Timp\ndispon', w:84, calc:true, center:true, fmt:'min' },
  { key:'disponibilitate', label:'Disponibilitate', w:98, calc:true, center:true, fmt:'pct' },
  { key:'performanta', label:'Performanța\n[%]', w:96, calc:true, center:true, fmt:'pct' },
  { key:'procent_calitate', label:'Procent\ncalitate', w:92, calc:true, center:true, fmt:'pct' },
  { key:'oee', label:'OEE', w:78, calc:true, center:true, fmt:'pct' }
];

function headerCell(col){
  const th = document.createElement('th');
  th.style.minWidth = col.w + 'px';
  th.style.maxWidth = col.w + 'px';
  const parts = String(col.label||'').split('\\n');
  th.innerHTML = parts.map(p=>p.trim()).join('<br>') + '<span class="flt"></span>';
  return th;
}

function render(){
  rowsPill.innerHTML = '<strong>' + (STATE.rows.length) + '</strong> rânduri';
  hdr.innerHTML = '';
  COLS.forEach(c=>hdr.appendChild(headerCell(c)));

  body.innerHTML = '';
  const canEdit = !!window.__CAN_EDIT__;

  STATE.rows.forEach((row, idx)=>{
    recalcRow(row);
    const tr = document.createElement('tr');

    COLS.forEach(col=>{
      const td = document.createElement('td');
      td.style.minWidth = col.w + 'px';
      td.style.maxWidth = col.w + 'px';

      if(col.calc){
        const div = document.createElement('div');
        div.className = 'cellText' + (col.center?' center':'') + (col.right?' right':'');

        let text = '';
        const v = row[col.key];
        if(col.fmt==='int') text = roInt(v);
        else if(col.fmt==='kg') text = (v && Math.abs(v - Math.round(v)) < 1e-9) ? roInt(v) : roNum(v, 3);
        else if(col.fmt==='sec') text = v ? roInt(v) + ' Sec.' : '';
        else if(col.fmt==='min') text = mins(v);
        else if(col.fmt==='pct') text = pct(v);
        else text = toStr(v);

        div.textContent = text;
        td.appendChild(div);
      } else {
        // editable
        if(col.type==='month'){
          const sel = document.createElement('select');
          sel.className = 'cellSel' + (col.center?' center':'');
          MONTHS.forEach(m=>{
            const o = document.createElement('option');
            o.value = m; o.textContent = m;
            sel.appendChild(o);
          });
          sel.value = toStr(row[col.key] || '').toLowerCase() || MONTHS[0];
          sel.disabled = !canEdit;
          sel.addEventListener('change', ()=>{ row[col.key] = sel.value; markDirty(); render(); });
          td.appendChild(sel);
        } else if(col.type==='shift'){
          const sel = document.createElement('select');
          sel.className = 'cellSel center';
          ['1','2','3'].forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; sel.appendChild(o); });
          sel.value = String(row[col.key] ?? '1');
          sel.disabled = !canEdit;
          sel.addEventListener('change', ()=>{ row[col.key] = sel.value; markDirty(); render(); });
          td.appendChild(sel);
        } else if(col.type==='port'){
          const sel = document.createElement('select');
          sel.className = 'cellSel';
          ['','1 PMF','2 PMF','3 PMF','4 PMF'].forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; sel.appendChild(o); });
          sel.value = toStr(row[col.key] ?? '');
          sel.disabled = !canEdit;
          sel.addEventListener('change', ()=>{ row[col.key] = sel.value; markDirty(); });
          td.appendChild(sel);
        } else {
          const inp = document.createElement('input');
          inp.className = 'cellInp' + (col.center?' center':'') + (col.right?' right':'');
          inp.disabled = !canEdit;

          // display formatting for diameter (match screenshot: "ø 71")
          if(col.type==='diam'){
            const raw = toStr(row[col.key] ?? '').trim();
            const r = raw.replace(/^ø\s*/i,'').trim();
            inp.value = raw ? (raw.match(/^ø/i) ? raw : (r ? ('ø ' + r) : '')) : '';
            inp.placeholder = 'ø 71';
          } else if(col.fmt==='min'){
            const n = toNum(row[col.key]);
            inp.value = (n>0) ? (roInt(n) + ' Min.') : '';
            inp.placeholder = '0 Min.';
          } else if(col.fmt==='sec'){
            const n = toNum(row[col.key]);
            inp.value = (n>0) ? (roInt(n) + ' Sec.') : '';
            inp.placeholder = '0 Sec.';
          } else if(col.type==='num'){
            const n = toNum(row[col.key]);
            if(col.showZero) inp.value = roInt(n);
            else inp.value = (n!==0) ? roInt(n) : (toStr(row[col.key] ?? '').trim() ? roInt(n) : '');
          } else {
            inp.value = toStr(row[col.key] ?? '');
          }

          // datalist bindings
          if(col.type==='ciocan') inp.setAttribute('list','dlCiocane');
          if(col.type==='reper') inp.setAttribute('list','dlRepere');

          inp.addEventListener('input', ()=>{
            row[col.key] = inp.value;
            if(col.key==='reper' || col.key==='ciocan'){
              // allow helpers to fill missing values once
              ensureHelperFields(row);
            }
            markDirty();
            // don't full render on each keystroke for speed on big tables
          });
          inp.addEventListener('blur', ()=>{ recalcRow(row); render(); });

          // conditional red for positive
          if(col.redIfPositive && toNum(row[col.key])>0){ inp.classList.add('red'); }
          td.appendChild(inp);
        }
      }

      // conditional red display for computed? (rebut, downtime)
      if(col.redIfPositive && col.calc){
        const v = toNum(row[col.key]);
        if(v>0){ td.firstChild && td.firstChild.classList.add('red'); }
      }

      tr.appendChild(td);
    });

    body.appendChild(tr);
  });
}

/* ===============================
   HELPERS (datalists)
   =============================== */
function rebuildDatalists(){
  const h = HELPERS || {};
  const dlCiocane = document.getElementById('dlCiocane');
  const dlRepere = document.getElementById('dlRepere');

  function fillDL(dl, arr){
    dl.innerHTML = '';
    (arr||[]).forEach(v=>{
      const opt = document.createElement('option');
      opt.value = String(v);
      dl.appendChild(opt);
    });
  }

  fillDL(dlCiocane, (h.utilaje_forja||[]));

  const repSet = new Set();
  (h.repere_debitare||[]).forEach(r=>{ const k=upper(r.REPER_DEBITARE); if(k) repSet.add(k); });
  (h.repere_forjate||[]).forEach(r=>{ const k=upper(r.REPER_FORJAT||r.REPER||r.REPER_FORJATE||r.REPER_DEBITARE); if(k) repSet.add(k); });
  fillDL(dlRepere, Array.from(repSet).sort());

  // refresh add modal selects
}

/* ===============================
   ADD MODAL
   =============================== */
const f = {
  an: document.getElementById('f_an'),
  luna: document.getElementById('f_luna'),
  data: document.getElementById('f_data'),
  schimb: document.getElementById('f_schimb'),
  ciocan: document.getElementById('f_ciocan'),
  reper: document.getElementById('f_reper'),
  diam: document.getElementById('f_diam'),
  cal: document.getElementById('f_cal'),
  marcaj: document.getElementById('f_marcaj'),
  cat_dk: document.getElementById('f_cat_dk'),
  cat_marc: document.getElementById('f_cat_marc'),
  port: document.getElementById('f_port'),
  sup: document.getElementById('f_sup'),
  sup_h: document.getElementById('f_sup_h'),
  inf: document.getElementById('f_inf'),
  inf_h: document.getElementById('f_inf_h'),
  buc: document.getElementById('f_buc'),
  rebut: document.getElementById('f_rebut'),
  tact: document.getElementById('f_tact'),
  inc: document.getElementById('f_inc'),
  sch: document.getElementById('f_sch'),
  reg: document.getElementById('f_reg'),
  opr: document.getElementById('f_opr'),
  pauza: document.getElementById('f_pauza')
};

function initMonthSelect(){
  f.luna.innerHTML = '';
  MONTHS.forEach(m=>{
    const o = document.createElement('option');
    o.value = m; o.textContent = m;
    f.luna.appendChild(o);
  });
}

function openModal(){
  if(!window.__CAN_EDIT__) return;

  const d = new Date();
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const yyyy = d.getFullYear();

  f.an.value = String(yyyy);
  f.luna.value = MONTHS[d.getMonth()];
  f.data.value = `${dd}.${mm}.${yyyy}`;
  f.schimb.value = '1';

  // reset rest
  [f.ciocan,f.reper,f.diam,f.cal,f.marcaj,f.cat_dk,f.cat_marc,f.sup,f.sup_h,f.inf,f.inf_h,f.buc,f.rebut,f.tact,f.inc,f.sch,f.reg,f.opr,f.pauza].forEach(x=>x.value='');
  f.port.value = '';

  modalBack.style.display = 'flex';
  setTimeout(()=>{ f.ciocan.focus(); }, 50);
}

function closeModal(){
  modalBack.style.display = 'none';
}

function rowFromForm(){
  const row = {
    id: uuid(),
    created_at: nowIso(),

    an: toStr(f.an.value).trim(),
    luna: toStr(f.luna.value).trim(),
    data: toStr(f.data.value).trim(),
    schimb: toStr(f.schimb.value).trim(),

    ciocan: toStr(f.ciocan.value).trim(),
    reper: toStr(f.reper.value).trim(),
    diametru: (function(){
      const raw = toStr(f.diam.value).trim();
      const r = raw.replace(/^ø\s*/i,'').trim();
      return r ? ('ø ' + r) : '';
    })(),
    calitate: toStr(f.cal.value).trim(),

    marcaj: toStr(f.marcaj.value).trim(),
    cod_cat_dk: toStr(f.cat_dk.value).trim(),
    cod_cat_marc: toStr(f.cat_marc.value).trim(),

    matrita_sup: toStr(f.sup.value).trim(),
    inaltime_sup: toNum(f.sup_h.value) || '',
    matrita_inf: toStr(f.inf.value).trim(),
    inaltime_inf: toNum(f.inf_h.value) || '',

    portmatrita: toStr(f.port.value).trim(),

    buc_realizate: toNum(f.buc.value) || 0,
    rebut: toNum(f.rebut.value) || 0,
    tact_sec: toNum(f.tact.value) || 0,

    schimbare_reper_min: toNum(f.sch.value) || 0,
    reglaj_min: toNum(f.reg.value) || 0,
    opriri_min: toNum(f.opr.value) || 0,
    incalzire_sdv_min: toNum(f.inc.value) || 0,
    pauza_masa_min: toNum(f.pauza.value) || 0,

    // helper-derived frozen fields
    kg_buc_debitat: 0,
    kg_buc_forjat: 0
  };

  // fill/freeze helper fields for this row
  ensureHelperFields(row);
  recalcRow(row);

  return row;
}

function saveRow(){
  const row = rowFromForm();
  if(!row.an || !row.luna || !row.data || !row.ciocan || !row.reper){
    alert('Completează minim: An, Lună, Data, Ciocan, Reper.');
    return;
  }
  STATE.rows.push(row);
  markDirty();
  render();
  closeModal();
}

/* Autocomplete helpers in modal */
function modalApplyHelpers(){
  const tmp = {
    reper: f.reper.value,
    ciocan: f.ciocan.value,
    diametru: f.diam.value,
    calitate: f.cal.value,
    tact_sec: toNum(f.tact.value) || 0,
    kg_buc_debitat: 0,
    kg_buc_forjat: 0
  };
  ensureHelperFields(tmp);
  if(!toStr(f.diam.value).trim() && toStr(tmp.diametru).trim()) f.diam.value = toStr(tmp.diametru);
  if(!toStr(f.cal.value).trim() && toStr(tmp.calitate).trim()) f.cal.value = toStr(tmp.calitate);
  if(!toNum(f.tact.value) && toNum(tmp.tact_sec)) f.tact.value = roInt(tmp.tact_sec);
}

/* ===============================
   EXPORT/IMPORT
   =============================== */
function exportJson(){
  const payload = getAllDataForExport();
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'forjate.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function exportXlsx(){
  if(!window.XLSX){ alert('Librăria Excel (XLSX) nu s-a încărcat.'); return; }
  const wb = XLSX.utils.book_new();

  const rows = STATE.rows.map(r=>{
    const x = { ...r };
    // add computed columns to export
    recalcRow(x);
    return {
      ANUL: x.an,
      LUNA: x.luna,
      DATA: x.data,
      SCHIMBUL: x.schimb,
      CIOCAN: x.ciocan,
      REPER: x.reper,
      DIAMETRU_OTEL: x.diametru,
      CALITATE_OTEL: x.calitate,
      MARCAJ_MATRITA: x.marcaj,
      COD_CAT_DK: x.cod_cat_dk,
      COD_CAT_MARC: x.cod_cat_marc,
      MATRITA_SUP: x.matrita_sup,
      INALTIME_MF_SUP: x.inaltime_sup,
      MATRITA_INF: x.matrita_inf,
      INALTIME_MF_INF: x.inaltime_inf,
      COMBINARE_MATRITE: x.combinare_matrite,
      DENUMIRE_PORTMATRITA: x.portmatrita,
      BUC_REALIZATE: x.buc_realizate,
      REBUT: x.rebut,
      PLANIFICAT: x.planificat,
      KG_SEMIF_DEBIT: x.kg_semif_debit,
      KG_FORJ: x.kg_forj,
      TACT_SEC: x.tact_sec,
      SCHIMBARE_REPER_MIN: x.schimbare_reper_min,
      REGLAJ_MIN: x.reglaj_min,
      OPRIRI_NEPLANIF_MIN: x.opriri_min,
      INCALZIRE_SDV_MIN: x.incalzire_sdv_min,
      PAUZA_MASA_MIN: x.pauza_masa_min,
      TIMP_DISPON_MIN: x.timp_dispon_min,
      DISPONIBILITATE: x.disponibilitate,
      PERFORMANTA: x.performanta,
      PROCENT_CALITATE: x.procent_calitate,
      OEE: x.oee
    };
  });

  const ws = XLSX.utils.json_to_sheet(rows);
  XLSX.utils.book_append_sheet(wb, ws, 'forjate');

  XLSX.writeFile(wb, 'forjate.xlsx');
}

function importXlsx(){
  if(!window.XLSX){ alert('Librăria Excel (XLSX) nu s-a încărcat.'); return; }
  if(!window.__CAN_EDIT__){ alert('Nu ai drept de editare (read-only).'); return; }

  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = '.xlsx,.xls';
  inp.onchange = async ()=>{
    const file = inp.files && inp.files[0];
    if(!file) return;
    const ab = await file.arrayBuffer();
    const wb = XLSX.read(ab, { type:'array' });
    const ws = wb.Sheets['forjate'] || wb.Sheets[wb.SheetNames[0]];
    const arr = XLSX.utils.sheet_to_json(ws, { defval:'' });
    if(!arr.length){ alert('Excel gol.'); return; }

    // map header variants -> internal keys
    const imported = arr.map(r=>{
      const row = {
        id: uuid(),
        created_at: nowIso(),
        an: r.ANUL ?? r.An ?? r.an ?? '',
        luna: (r.LUNA ?? r.Lună ?? r.luna ?? '').toString().toLowerCase(),
        data: r.DATA ?? r.Data ?? r.data ?? '',
        schimb: r.SCHIMBUL ?? r.Schimbul ?? r.schimb ?? '1',
        ciocan: r.CIOCAN ?? r.Ciocan ?? r.utilaj ?? '',
        reper: r.REPER ?? r.Reper ?? '',
        diametru: (function(){
          const raw = String(r.DIAMETRU_OTEL ?? r.Diametru ?? r.Diametru_otel ?? '').trim();
          const rr = raw.replace(/^ø\s*/i,'').trim();
          return rr ? ('ø ' + rr) : '';
        })(),
        calitate: r.CALITATE_OTEL ?? r.Calitate ?? '',
        marcaj: r.MARCAJ_MATRITA ?? r.Marcaj ?? '',
        cod_cat_dk: r.COD_CAT_DK ?? '',
        cod_cat_marc: r.COD_CAT_MARC ?? '',
        matrita_sup: r.MATRITA_SUP ?? '',
        inaltime_sup: r.INALTIME_MF_SUP ?? r.Inaltime_MF_SUP ?? '',
        matrita_inf: r.MATRITA_INF ?? '',
        inaltime_inf: r.INALTIME_MF_INF ?? r.Inaltime_MF_INF ?? '',
        portmatrita: r.DENUMIRE_PORTMATRITA ?? r.Portmatrita ?? '',
        buc_realizate: toNum(r.BUC_REALIZATE ?? r.Buc_realizate ?? r.BUC ?? 0),
        rebut: toNum(r.REBUT ?? r.Rebut ?? 0),
        tact_sec: toNum(r.TACT_SEC ?? r.Tact ?? 0),
        schimbare_reper_min: toNum(r.SCHIMBARE_REPER_MIN ?? r.Schimbare_reper ?? 0),
        reglaj_min: toNum(r.REGLAJ_MIN ?? r.Reglaj ?? 0),
        opriri_min: toNum(r.OPRIRI_NEPLANIF_MIN ?? r.Opriri ?? 0),
        incalzire_sdv_min: toNum(r.INCALZIRE_SDV_MIN ?? r.Incalzire ?? 0),
        pauza_masa_min: toNum(r.PAUZA_MASA_MIN ?? r.Pauza ?? 0),
        kg_buc_debitat: toNum(r.KG_BUC_DEBITAT ?? 0),
        kg_buc_forjat: toNum(r.KG_BUC_FORJAT ?? 0)
      };
      ensureHelperFields(row);
      recalcRow(row);
      return row;
    });

    if(!confirm('Import: ' + imported.length + ' rânduri. Se adaugă la ce există deja. Continui?')) return;
    STATE.rows.push(...imported);
    markDirty();
    render();
  };
  inp.click();
}

/* ===============================
   RF AUTH + ROLE
   =============================== */
const supa = (window.supabase && window.supabase.createClient)
  ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:false } })
  : null;
window.__SUPA__ = supa;

async function getRole(){
  if(!supa) return { ok:false, role:'viewer', email:'' };
  const { data: { user } } = await supa.auth.getUser();
  if(!user) return { ok:false, role:'viewer', email:'' };
  try{
    const { data, error } = await supa.from('profiles').select('role').eq('id', user.id).maybeSingle();
    if(error) throw error;
    const role = (data && data.role) ? String(data.role) : 'viewer';
    return { ok:true, role, email: user.email || '' };
  }catch(_e){
    return { ok:true, role:'viewer', email: user.email || '' };
  }
}

function applyRole(role, email){
  window.__APP_ROLE__ = role;
  window.__CAN_EDIT__ = (role==='admin' || role==='editor');

  roleBadge.style.display = 'inline-flex';
  roleText.textContent = role.toUpperCase() + (role==='viewer' ? ' (read-only)' : '') + (email ? ' • ' + email : '');
  roleDot.style.background = (role==='viewer') ? '#64748b' : '#16a34a';

  document.getElementById('btnAdd').style.display = window.__CAN_EDIT__ ? 'inline-flex' : 'none';
  document.getElementById('btnImportXlsx').style.display = window.__CAN_EDIT__ ? 'inline-flex' : 'none';
  document.getElementById('btnReset').style.display = window.__CAN_EDIT__ ? 'inline-flex' : 'none';
}

/* ===============================
   CLOUD SYNC
   =============================== */
let lastPulledAt = null;
let lastPushedAt = null;
let pollTimer = null;
let pushTimer = null;
let inFlight = false;

function setCloud(ok, msg){
  cloudBadge.style.display = 'inline-flex';
  cloudBadge.classList.remove('ok','bad','warn');
  cloudBadge.classList.add(ok ? 'ok' : 'bad');
  cloudBadge.textContent = msg || (ok ? 'Cloud: ON' : 'Cloud: eroare');
}

function getAllDataForExport(){
  return {
    version: STATE.version,
    updated_at: STATE.updated_at || nowIso(),
    rows: STATE.rows
  };
}
window.getAllDataForExport = getAllDataForExport;

function loadFromPayload(payload){
  if(!payload || !Array.isArray(payload.rows)) return false;

  // edit-safe: don't apply while editing
  const ae = document.activeElement;
  if(ae && (ae.tagName==='INPUT' || ae.tagName==='TEXTAREA' || ae.tagName==='SELECT')) return false;

  STATE.rows = payload.rows;
  STATE.updated_at = payload.updated_at || null;
  recalcAll();
  render();

  try{ localStorage.setItem(LS_KEY_DATA, JSON.stringify(payload)); }catch(_e){}
  return true;
}
window.loadFromPayload = loadFromPayload;

async function pull(){
  if(!supa) return;
  if(inFlight) return;

  // if local pending very recent, avoid overwriting
  if(__HAS_LOCAL_PENDING && (Date.now() - __LAST_LOCAL_CHANGE) < 4000){
    setCloud(true, 'Cloud: ON');
    return;
  }

  inFlight = true;
  try{
    const { data, error } = await supa.from(DOC_TABLE).select('data,updated_at').eq('doc_key', DOC_KEY).maybeSingle();
    if(error) throw error;
    if(!data || !data.data){ setCloud(true, 'Cloud: gol'); return; }

    const ts = data.updated_at || null;
    if(lastPulledAt && ts && new Date(ts) <= new Date(lastPulledAt)) { setCloud(true,'Cloud: ON'); return; }
    if(lastPushedAt && ts && new Date(ts) <= new Date(lastPushedAt)) { setCloud(true,'Cloud: ON'); return; }

    const applied = loadFromPayload(data.data);
    if(applied) lastPulledAt = ts || nowIso();
    setCloud(true, 'Cloud: ON');
  }catch(e){
    console.error(e);
    setCloud(false, 'Cloud: eroare');
  }finally{
    inFlight = false;
  }
}

function schedulePush(){
  if(!window.__CAN_EDIT__) return;
  if(pushTimer) clearTimeout(pushTimer);
  pushTimer = setTimeout(async ()=>{
    try{
      const payload = getAllDataForExport();
      payload.updated_at = nowIso();

      const up = { doc_key: DOC_KEY, data: payload, updated_at: payload.updated_at };
      const { error } = await supa.from(DOC_TABLE).upsert(up, { onConflict:'doc_key' });
      if(error) throw error;

      lastPushedAt = up.updated_at;
      __HAS_LOCAL_PENDING = false;
      setCloud(true, 'Cloud: ON');
    }catch(e){
      console.error(e);
      const msg = (String(e && e.message || '').toLowerCase().includes('row level security') || String(e).toLowerCase().includes('permission'))
        ? 'Cloud: fără drept de scriere'
        : 'Cloud: eroare';
      setCloud(false, msg);
    }
  }, 550);
}

window.notifyDataChanged = schedulePush;

async function startCloud(){
  if(!supa){
    lock.style.display = 'flex';
    return;
  }

  const { data: sess } = await supa.auth.getSession();
  if(!sess || !sess.session || !sess.session.user){
    lock.style.display = 'flex';
    return;
  }

  cloudBadge.style.display = 'inline-flex';
  cloudBadge.classList.add('warn');
  cloudBadge.textContent = 'Cloud: conectez…';

  // initial pull
  await pull();

  // polling
  pollTimer = setInterval(pull, 2500);
  setCloud(true, 'Cloud: ON');
}

/* ===============================
   HELPERS CLOUD PULL (doc_key=helpers)
   =============================== */
let helpersLastTs = null;
async function pullHelpers(){
  if(!supa) return;
  try{
    const { data, error } = await supa.from(DOC_TABLE).select('data,updated_at').eq('doc_key','helpers').maybeSingle();
    if(error) throw error;
    if(!data || !data.data) return;
    const ts = data.updated_at || null;
    if(helpersLastTs && ts && new Date(ts) <= new Date(helpersLastTs)) return;
    helpersLastTs = ts || nowIso();
    HELPERS = data.data;
    try{ localStorage.setItem(LS_KEY_HELPERS, JSON.stringify(HELPERS)); }catch(_e){}
    rebuildDatalists();
  }catch(e){
    // don't spam
  }
}

/* ===============================
   EVENTS
   =============================== */
document.getElementById('btnBack').addEventListener('click', ()=>{ window.location.href = 'index.html'; });
document.getElementById('btnToDash').addEventListener('click', ()=>{ window.location.href = 'index.html'; });

document.getElementById('btnAdd').addEventListener('click', openModal);
document.getElementById('btnClose').addEventListener('click', closeModal);
document.getElementById('btnCancel').addEventListener('click', closeModal);
document.getElementById('btnSave').addEventListener('click', saveRow);
modalBack.addEventListener('click', (e)=>{ if(e.target === modalBack) closeModal(); });

document.getElementById('btnExportJson').addEventListener('click', exportJson);
document.getElementById('btnExportXlsx').addEventListener('click', exportXlsx);
document.getElementById('btnImportXlsx').addEventListener('click', importXlsx);

document.getElementById('btnReset').addEventListener('click', ()=>{
  if(!window.__CAN_EDIT__) return;
  if(!confirm('Reset: șterg toate rândurile din această pagină (local + cloud la următorul sync). Continui?')) return;
  STATE.rows = [];
  markDirty();
  render();
});

// Modal helper autofill
f.reper.addEventListener('input', modalApplyHelpers);
f.ciocan.addEventListener('input', modalApplyHelpers);

// Escape closes modal
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modalBack.style.display==='flex') closeModal(); });

// HELPERS_UPDATED broadcast
window.addEventListener('message', (e)=>{
  if(e && e.data && e.data.type === 'HELPERS_UPDATED'){
    loadHelpersLocal();
    rebuildDatalists();
    // do not retro-change kg/tact for existing rows (they are frozen), but recalc computed
    recalcAll();
    render();
  }
});

/* ===============================
   INIT
   =============================== */
(function init(){
  initMonthSelect();

  // load local
  loadLocal();
  loadHelpersLocal();
  rebuildDatalists();
  recalcAll();
  render();

  // role + cloud
  getRole().then(({ ok, role, email })=>{
    if(!ok){
      lock.style.display = 'flex';
      return;
    }
    applyRole(role, email);
    startCloud();
    pullHelpers();
    setInterval(pullHelpers, 5000);
  });
})();
</script>
</body>
</html>
