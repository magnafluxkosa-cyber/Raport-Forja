<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NUMERALKOD ‚Äì Zale + Alte repere</title>
  <style>
    :root{
      --grid:#000000;
      --hdr:#b7d7f0;
      --yellow:#fff176;
      --orange:#f4b400;
      --white:#ffffff;
      --muted:#475569;
      --border:#cfd8e3;
      --focus:#2563eb;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family: Calibri, Arial, sans-serif; background:#f3f6fb; color:#111; }

    .toolbar{
      position: sticky; top: 0; z-index: 50;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:10px 12px; background: rgba(255,255,255,.95);
      border-bottom:1px solid var(--border);
    }
    .title{ font-weight:800; margin-right:6px; }
    button{
      border:1px solid #94a3b8; background:#ffffff;
      padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700;
    }
    button:hover{ background:#f8fafc; }
    .hint{ margin-left:auto; color:var(--muted); font-size:12px; font-weight:600; }

    .wrap{ padding:12px 10px 26px; overflow-x:auto; }
.dual{
  width: min(100%, 2000px);
  margin: 0 auto;
  display:grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 1fr); /* mereu 2 tabele una l√¢ngƒÉ alta; se mic»ôoreazƒÉ ca sƒÉ √ÆncapƒÉ */
  gap:12px;
}
@media (max-width: 1100px){
      .hint{ width:100%; margin-left:0; }
    }


    .bucket{
      background:#fff;
      border:1px solid #d6deea;
      border-radius:12px;
      box-shadow: 0 6px 18px rgba(15,23,42,.06);
      overflow:hidden;
      min-width: 0;
    }
    .bucketHead{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:10px 10px 8px;
      border-bottom:1px solid #e2e8f0;
      background: linear-gradient(180deg, rgba(183,215,240,.55), rgba(255,255,255,.95));
    }
    .bucketTitle{ font-weight:900; color:#0f172a; }
    .bucketSub{ color:var(--muted); font-size:12px; font-weight:600; }
    .bucketHead .spacer{ flex:1 1 auto; }
    .btnAdd{
      border:1px solid #2563eb;
      background:#2563eb;
      color:#fff;
    }
    .btnAdd:hover{ background:#1d4ed8; }

    .btnMini{ padding:7px 10px; border-radius:10px; font-weight:800; font-size:12px; }
    .btnDark{
      border:1px solid #0f172a;
      background:#0f172a;
      color:#fff;
    }
    .btnDark:hover{ background:#111827; }

    .tableWrap{
      overflow:auto;
      padding-right: 12px; /* spa»õiu pt scrollbar */
      min-height: 320px; /* fallback c√¢nd iframe e ascuns la init */
    }

    

    .reserveSection{
      width: min(100%, 2000px);
      margin: 12px auto 0;
      display:grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap:12px;
      align-items:flex-start;
    }
    .bucketRez{ min-width:0; }
    .reserveSpacer{ min-width:0; }
/* celule blocate de NUMERALKOD rezervat (doar de la MARCAJ SARJA spre dreapta) */
    tr.lockedRow td.lock{ background:#ffe4e6 !important; }
    tr.lockedRow td.lock.orange{ background:#fda4af !important; }
    tr.lockedRow td.lock.editable{ color:#111; }
    tr.lockedRow td.lock.editable[contenteditable="false"]{ cursor:not-allowed; }
    tr.lockedRow td.lock.dropdown input:disabled{ cursor:not-allowed; opacity:0.75; background:#ffe4e6; }
.iconbtn{
      border:1px solid #94a3b8;
      background:#fff;
      border-radius:10px;
      padding:6px 9px;
      font-weight:900;
      cursor:pointer;
    }
    .iconbtn:hover{ background:#f8fafc; }
    .iconbtn.danger{ border-color:#ef4444; color:#b91c1c; }
    .iconbtn.danger:hover{ background:#fef2f2; }

table{
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      background: var(--white);
      border: 2px solid var(--grid);
    }
    th, td{
  border: 1px solid var(--grid);
  padding: 3px 4px;
  min-height: 22px;
  height: auto;
  font-size: 11px;
  vertical-align: middle;
  text-align:center;
  overflow-wrap: anywhere;
  word-break: break-word;
}
td{ white-space: normal; }
thead th{
  background: var(--hdr);
  font-weight:900;
  position: sticky; top: 0; z-index: 5;
  white-space: normal; /* titluri pe 2+ r√¢nduri, nu se mai taie */
  line-height: 1.05;
  padding: 6px 4px;
}
col.c-numar{ width:7%; }
col.c-1, col.c-2, col.c-3{ width:5%; }
col.c-numar2{ width:7%; }
col.c-seria{ width:7%; }
col.c-marcaj{ width:11%; }
col.c-dim{ width:13%; }
col.c-cal{ width:14%; }
col.c-sarja{ width:13%; }
col.c-scurt{ width:13%; }
td.yellow{ background:var(--yellow); font-weight:800; }
    td.orange{ background:var(--orange); font-weight:800; }
    td.editable{ background:var(--white); text-align:left; padding-left:10px; }
    td.editable[contenteditable="true"]:focus{ outline: 2px solid var(--focus); outline-offset: -2px; }

    td.dropdown{ padding:0; background:var(--white); }
    td.dropdown input{
      width:100%;
      height:28px;
      border:0;
      padding:0 10px;
      font-family: inherit;
      font-size:12px;
      background:transparent;
      outline:none;
      text-align:left;
    }
    td.dropdown input:focus{ outline: 2px solid var(--focus); outline-offset:-2px; }

    #storageBanner{
      display:none;
      max-width:1820px;
      margin: 10px auto 0;
      padding:10px 12px;
      background:#fff7ed;
      border:1px solid #fb923c;
      border-radius:12px;
      color:#7c2d12;
      font-size:12px;
      font-weight:700;
    }

    #errorBox{
      max-width:1820px;
      margin: 10px auto 0;
      padding:10px 12px;
      background:#fff1f2;
      border:1px solid #fb7185;
      border-radius:12px;
      color:#7f1d1d;
      display:none;
      white-space:pre-wrap;
      font-weight:800;
    }
  
  .badgeCloud{margin-left:12px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.18);color:#cbd5e1;font-size:12px}
  .badgeCloud.ok{border-color:rgba(34,197,94,.35);color:#bbf7d0;background:rgba(34,197,94,.10)}

/* ===== Mobile layout fix (v2.7) ===== */
@media (max-width: 980px){
  .rfnk-grid,
  .twoTables,
  .tables-wrap,
  .grid-2,
  .grid2,
  .main-grid{
    display:block !important;
  }

  /* generic cards side-by-side -> stacked */
  [class*="grid"]{
    gap:12px;
  }

  /* put cards one under another */
  .card, .panel, .box{
    width:100% !important;
    margin-bottom:12px;
  }

  /* horizontal scroll for wide tables */
  .table-scroll,
  .tbl-wrap,
  .tableWrap,
  .table-container,
  .tableContainer{
    overflow-x:auto !important;
    -webkit-overflow-scrolling: touch;
    width:100%;
  }

  table{
    min-width: 720px !important; /* keeps columns readable */
  }

  /* if parent cards directly contain tables */
  .card table, .panel table, .box table{
    min-width: 720px !important;
    display: table;
  }

  /* buttons stack nicer */
  .toolbar, .btn-row, .actions, .top-actions{
    display:flex !important;
    flex-wrap:wrap !important;
    gap:8px !important;
  }
  .toolbar > *, .btn-row > *, .actions > *, .top-actions > *{
    flex: 1 1 auto;
  }

  /* top title + menu button alignment */
  h1, .title, .page-title{
    word-break:break-word;
  }

  /* make text less cramped */
  th, td{
    font-size:14px !important;
    line-height:1.2;
  }
}

/* extra small phones */
@media (max-width: 600px){
  table{
    min-width: 820px !important;
  }
  .card table, .panel table, .box table{
    min-width: 820px !important;
  }
}

</style>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
function goDashboard(){ window.location.href = 'index.html'; }
</script>
</head>
<body>
  <div class="toolbar">
    <div class="title">NUMERALKOD</div>
    <button onclick="goMenu()">‚¨Ö Dashboard</button>
    <button onclick="resetAll()">Reset (pƒÉstreazƒÉ doar N1 √Æn ZALE)</button>
    <button onclick="clearAutosave()">üóëÔ∏è »òterge Auto‚ÄëSave</button>
    <button class="btnMini btnDark" onclick="exportXLSX(\'all\')">‚§ì Export Excel</button>
    <button class="btnMini btnDark" onclick="importXLSX(\'all\')">‚§í Import Excel</button>

    <button id="btnCloudSave" class="btnMini btnDark" onclick="cloudSaveNow()" title="SalveazƒÉ manual √Æn cloud">‚òÅÔ∏è SalveazƒÉ √Æn Cloud</button>
    <button id="btnCloudPull" class="btnMini" onclick="cloudPullNow()" title="√éncarcƒÉ manual din cloud">üîÑ √éncarcƒÉ din Cloud</button>
    <span id="cloudBadge" class="badgeCloud">Cloud: ‚Ä¶</span>

    <input id="fileImportXLSX" type="file" accept=".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" style="display:none" />
    <div class="hint">2 tabele fixe (10 r√¢nduri vizibile) + scroll. Adaugi SERIA (ex: N5, D10, M5). Duplicatele sunt blocate √Æntre ZALE »ôi ALTE REPERE.</div>
  </div>

  <div id="storageBanner">
    Aten»õie: Browserul a blocat salvarea automatƒÉ (localStorage) pentru fi»ôiere locale. Datele NU vor rƒÉm√¢ne dupƒÉ √Ænchidere.
    Folose»ôte pagina INTRARI_OTEL (unde ai confirmat cƒÉ se salveazƒÉ) ca reper.
  </div>

  <div id="errorBox"></div>

  <div class="wrap">
    <div class="dual">
      <div class="bucket">
        <div class="bucketHead">
          <div>
            <div class="bucketTitle">NUMERALKOD zale</div>
            <div class="bucketSub">SetƒÉri pentru ZALE (prefix + completƒÉri: dimensiune / calitate / sarjƒÉ / cod scurt).</div>
          </div>
          <div class="spacer"></div>
          <button class="btnMini btnDark" onclick="exportXLSX('zale')">‚§ì Export</button>
          <button class="btnMini btnDark" onclick="importXLSX('zale')">‚§í Import</button>
          <button class="btnAdd" onclick="addSeriesPrompt('zale')">‚ûï AdaugƒÉ SERIA √Æn ZALE</button>
        </div>
        <div class="tableWrap" id="wrapZale">
          <table id="tblZale">
            <colgroup>
              <col class="c-numar">
              <col class="c-1"><col class="c-2"><col class="c-3">
              <col class="c-numar2">
              <col class="c-seria">
              <col class="c-marcaj">
              <col class="c-dim">
              <col class="c-cal">
              <col class="c-sarja">
              <col class="c-scurt">
            </colgroup>
            <thead>
              <tr>
                <th>NUMAR</th>
                <th>1</th><th>2</th><th>3</th>
                <th>NUMAR2</th>
                <th>SERIA</th>
                <th>MARCAJ SARJA</th>
                <th>DIMENSIUNE MATERIAL</th>
                <th>CALITATE (Grade)</th>
                <th>SARJA OTEL</th>
                <th>COD SCURT</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="bucket">
        <div class="bucketHead">
          <div>
            <div class="bucketTitle">NUMERALKOD alte repere</div>
            <div class="bucketSub">SetƒÉri pentru ALTE REPERE (acelea»ôi reguli, listƒÉ separatƒÉ).</div>
          </div>
          <div class="spacer"></div>
          <button class="btnMini btnDark" onclick="exportXLSX('alte')">‚§ì Export</button>
          <button class="btnMini btnDark" onclick="importXLSX('alte')">‚§í Import</button>
          <button class="btnAdd" onclick="addSeriesPrompt('alte')">‚ûï AdaugƒÉ SERIA √Æn ALTE REPERE</button>
        </div>
        <div class="tableWrap" id="wrapAlte">
          <table id="tblAlte">
            <colgroup>
              <col class="c-numar">
              <col class="c-1"><col class="c-2"><col class="c-3">
              <col class="c-numar2">
              <col class="c-seria">
              <col class="c-marcaj">
              <col class="c-dim">
              <col class="c-cal">
              <col class="c-sarja">
              <col class="c-scurt">
            </colgroup>
            <thead>
              <tr>
                <th>NUMAR</th>
                <th>1</th><th>2</th><th>3</th>
                <th>NUMAR2</th>
                <th>SERIA</th>
                <th>MARCAJ SARJA</th>
                <th>DIMENSIUNE MATERIAL</th>
                <th>CALITATE (Grade)</th>
                <th>SARJA OTEL</th>
                <th>COD SCURT</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

    </div>
  </div>

  <div class="reserveSection">
    <div class="bucket bucketRez">
      <div class="bucketHead">
        <div>
          <div class="bucketTitle">NUMERALKOD rezervat</div>
          <div class="bucketSub">Orice cod introdus √Æn <b>MARCAJ SARJA</b> aici blocheazƒÉ automat r√¢ndul corespunzƒÉtor √Æn ZALE »ôi ALTE REPERE (nu mai po»õi completa DIM/Calitate/SarjƒÉ/Cod scurt pe acel r√¢nd).</div>
        </div>
        <div class="spacer"></div>
        <button class="btnMini btnDark" onclick="exportXLSX('rez')">‚§ì Export</button>
        <button class="btnMini btnDark" onclick="importXLSX('rez')">‚§í Import</button>
        <button class="btnAdd" onclick="addReservedRow()">‚ûï AdaugƒÉ COD rezervat</button>
      </div>
      <div class="tableWrap" id="wrapRez">
        <table id="tblRez">
          <colgroup>
            <col style="width:16%">
            <col style="width:20%">
            <col style="width:20%">
            <col style="width:16%">
            <col style="width:20%">
            <col style="width:8%">
          </colgroup>
          <thead>
            <tr>
              <th>MARCAJ SARJA</th>
              <th>DIMENSIUNE MATERIAL</th>
              <th>CALITATE (Grade)</th>
              <th>SARJA OTEL</th>
              <th>REPER rezervat</th>
              <th>ACT</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="reserveSpacer"></div>
</div>


  <!-- Lista pentru CALITATE -->
  <datalist id="gradeList">
    <option value="1E-1287/15B34"></option>
    <option value="1E1239G"></option>
    <option value="1E0361 (C-45)"></option>
    <option value="C35"></option>
    <option value="C45"></option>
    <option value="30MnVS6"></option>
    <option value="S-355"></option>
    <option value="C25"></option>
    <option value="1E-0042"></option>
    <option value="16MnCr05"></option>
    <option value="C60"></option>
    <option value="1E-1497"></option>
    <option value="1E0621/15B22"></option>
    <option value="1E0509"></option>
    <option value="30CrNiMo8"></option>
    <option value="1E4808"></option>
  </datalist>

  <datalist id="forjateList"></datalist>


<script>
/* === Diagnostic: afi»ôeazƒÉ erori JS direct pe paginƒÉ === */
(function(){
  const box = document.getElementById('errorBox');
  window.addEventListener('error', (e) => {
    box.style.display = 'block';
    box.textContent = "Eroare JavaScript detectatƒÉ:\n" + (e.message || e.error || "necunoscut") +
      (e.filename ? "\nFi»ôier: " + e.filename : "") +
      (e.lineno ? "\nLinie: " + e.lineno : "");
  });
})();

const LETTERS = ["N","U","M","E","R","A","L","K","O","D"];
const AUTO_KEY = "NUMERALKOD_autosave_v1";

function goMenu(){
  window.location.href = 'index.html';
}

function storageAvailable(){
  try{
    const k="__test__";
    window.localStorage.setItem(k,"1");
    window.localStorage.removeItem(k);
    return true;
  }catch(e){ return false; }
}
const CAN_AUTOSAVE = storageAvailable();
(function(){
  const b = document.getElementById('storageBanner');
  if (b) b.style.display = CAN_AUTOSAVE ? "none" : "block";
})();

function showMsg(msg){
  const box = document.getElementById('errorBox');
  box.style.display = 'block';
  box.textContent = msg;
  clearTimeout(showMsg._t);
  showMsg._t = setTimeout(() => { box.style.display='none'; }, 4500);
}

/* ====== STATE ====== */
let state = {
  zale: [],
  alte: [],
  rez: []
};

function normalizeSeries(input){
  return (input || "").toString().toUpperCase().replace(/\s+/g,'');
}
function validateSeries(series){
  const m = series.match(/^([A-Z])(\d{1,2})$/);
  if (!m) return {ok:false, err:"Format invalid. Exemplu corect: N5, D10, M5."};
  const first = m[1];
  const idx = Number(m[2]);
  if (!LETTERS.includes(first)) return {ok:false, err:"Litera seriei trebuie sƒÉ fie din setul: " + LETTERS.join(" ")};
  if (!(idx >= 1 && idx <= 10)) return {ok:false, err:"NumƒÉrul trebuie sƒÉ fie √Æntre 1 »ôi 10."};
  return {ok:true, first, idx};
}
function prefixFor(series){
  const v = validateSeries(series);
  if (!v.ok) return "";
  const second = LETTERS[v.idx-1];
  return v.first + second;
}
function hasSeries(group, series){
  return state[group].some(x => x.series === series);
}
function findGroupOfSeries(series){
  if (hasSeries('zale', series)) return 'zale';
  if (hasSeries('alte', series)) return 'alte';
  return null;
}
function makeSeriesObj(series){
  return {
    series,
    rows: LETTERS.map(() => ({dim:"", grade:"", sarja:"", scurt:""}))
  };
}



/* ====== NUMERALKOD REZERVAT ====== */
function normalizeMarcaj(input){
  return (input || "").toString().toUpperCase().replace(/\s+/g,'');
}

function inferSeriesFromMarcaj(code){
  const c = normalizeMarcaj(code);
  if (!c || c.length < 2) return "";
  const first = c.charAt(0);
  const second = c.charAt(1);
  const idx = LETTERS.indexOf(second) + 1;
  if (idx <= 0) return "";
  return first + String(idx);
}

function validateMarcaj(code){
  const c = normalizeMarcaj(code);
  if (!c) return {ok:false, err:"MARCAJ SARJA este obligatoriu."};
  if (!/^[A-Z]{3}$/.test(c)) return {ok:false, err:"MARCAJ SARJA trebuie sƒÉ aibƒÉ 3 litere (ex: NNN)."};
  for (const ch of c){
    if (!LETTERS.includes(ch)) return {ok:false, err:"MARCAJ SARJA trebuie format doar din literele: " + LETTERS.join(" ")};
  }
  return {ok:true, code:c};
}
function reservedSet(){
  const set = new Set();
  (state.rez || []).forEach(r => {
    const c = normalizeMarcaj(r.marcaj);
    if (c) set.add(c);
  });
  return set;
}
function isReserved(marcaj){
  return reservedSet().has(normalizeMarcaj(marcaj));
}
function reservedForSeries(series){
  const pref = prefixFor(series);
  if (!pref) return [];
  const set = reservedSet();
  const hit = [];
  for (const third of LETTERS){
    const code = pref + third;
    if (set.has(code)) hit.push(code);
  }
  return hit;
}
/* ====== RENDER ====== */
function render(){
  // pƒÉstreazƒÉ scroll-ul (ca sƒÉ nu te arunce sus c√¢nd se aplicƒÉ blocƒÉrile)
  const wz = document.getElementById('wrapZale');
  const wa = document.getElementById('wrapAlte');
  const wr = document.getElementById('wrapRez');
  const sz = wz ? wz.scrollTop : 0;
  const sa = wa ? wa.scrollTop : 0;
  const sr = wr ? wr.scrollTop : 0;

  renderGroup('zale');
  renderGroup('alte');
  renderReserved();
  applyReservedLocksDom();

  adjustVisibleRows(); // keep wrappers equal and ~10 rows visible

  if (wz) wz.scrollTop = sz;
  if (wa) wa.scrollTop = sa;
  if (wr) wr.scrollTop = sr;
}

function cellEditable(field, group, sIndex, rIndex, value, locked){
  const safe = (value || "").toString();
  const ce = locked ? "false" : "true";
  return `<td class="editable${locked ? " lock" : ""}" contenteditable="${ce}" spellcheck="false"
              data-field="${field}" data-group="${group}" data-s="${sIndex}" data-r="${rIndex}">${escapeHtml(safe)}</td>`;
}

function cellGrade(group, sIndex, rIndex, value, locked){
  const safe = (value || "").toString();
  const dis = locked ? "disabled" : "";
  return `<td class="dropdown${locked ? " lock" : ""}" data-group="${group}" data-s="${sIndex}" data-r="${rIndex}">
            <input list="gradeList" value="${escapeAttr(safe)}" ${dis} />
          </td>`;
}

function escapeHtml(s){
  return s.replace(/&/g,"&").replace(/</g,"<").replace(/>/g,">");
}
function escapeAttr(s){
  return escapeHtml(s).replace(/"/g,"&amp;quot;");
}

function renderGroup(group){
  const rezSet = reservedSet();
  const tbl = document.getElementById(group === 'zale' ? 'tblZale' : 'tblAlte');
  const tbody = tbl.querySelector('tbody');
  const parts = [];

  state[group].forEach((serieObj, sIndex) => {
    const series = serieObj.series;
    const pref = prefixFor(series);
    serieObj.rows.forEach((row, rIndex) => {
      const third = LETTERS[rIndex];
      const marcaj = pref + third;
      const locked = rezSet.has(marcaj);

      parts.push(locked ? '<tr class="lockedRow" data-locked="1">':'<tr>');
      parts.push(`<td>${rIndex+1}</td>`);
      parts.push(`<td class="yellow">${third}</td>`);
      parts.push(`<td class="yellow">${third}</td>`);
      parts.push(`<td class="yellow">${third}</td>`);
      parts.push(`<td>${rIndex+1}</td>`);

      if (rIndex === 0){
        parts.push(`<td class="orange" rowspan="10">${series}</td>`);
      }
      parts.push(`<td class="orange${locked ? " lock" : ""}">${marcaj}</td>`);

      parts.push(cellEditable('dim', group, sIndex, rIndex, row.dim, locked));
      parts.push(cellGrade(group, sIndex, rIndex, row.grade, locked));
      parts.push(cellEditable('sarja', group, sIndex, rIndex, row.sarja, locked));
      parts.push(cellEditable('scurt', group, sIndex, rIndex, row.scurt, locked));

      parts.push('</tr>');
    });
  });

  tbody.innerHTML = parts.join('');
}

function rezCellEditable(field, idx, value){
  const safe = (value || "").toString();
  return `<td class="editable" contenteditable="true" spellcheck="false" data-rez="1" data-field="${field}" data-i="${idx}">${escapeHtml(safe)}</td>`;
}
function rezCellGrade(idx, value){
  const safe = (value || "").toString();
  return `<td class="dropdown" data-rez="1" data-field="grade" data-i="${idx}">
            <input list="gradeList" value="${escapeAttr(safe)}" />
          </td>`;
}

function rezCellReper(idx, value){
  const safe = (value || "").toString();
  return `<td class="dropdown" data-rez="1" data-field="reper" data-i="${idx}">
            <input list="forjateList" value="${escapeAttr(safe)}" placeholder="alege reper..." />
          </td>`;
}
function renderReserved(){
  const tbl = document.getElementById('tblRez');
  if (!tbl) return;
  const tbody = tbl.querySelector('tbody');
  const parts = [];
  (state.rez || []).forEach((r, idx) => {
    parts.push('<tr>');
    parts.push(rezCellEditable('marcaj', idx, r.marcaj));
    parts.push(rezCellEditable('dim', idx, r.dim));
    parts.push(rezCellGrade(idx, r.grade));
    parts.push(rezCellEditable('sarja', idx, r.sarja));
    parts.push(rezCellReper(idx, r.reper));
    parts.push(`<td class="center"><button class="iconbtn danger" onclick="deleteReservedRow(${idx})">üóë</button></td>`);
    parts.push('</tr>');
  });
  tbody.innerHTML = parts.join('');
}

function applyReservedLocksDom(){
  const set = reservedSet();
  ['tblZale','tblAlte'].forEach(tid => {
    const tbl = document.getElementById(tid);
    if (!tbl) return;
    tbl.querySelectorAll('tbody tr').forEach(tr => {
      const orangeCells = Array.from(tr.querySelectorAll('td.orange'));
      const marcajTd = orangeCells.find(td => /^[A-Z]{3}$/.test((td.textContent||'').trim()));
      if (!marcajTd) return;

      const code = normalizeMarcaj((marcajTd.textContent||'').trim());
      const locked = set.has(code);

      const toLock = [];
      let cur = marcajTd;
      while (cur){
        if (cur.tagName === 'TD') toLock.push(cur);
        cur = cur.nextElementSibling;
      }

      if (locked){
        tr.classList.add('lockedRow');
        tr.dataset.locked = "1";
        toLock.forEach(td => {
          td.classList.add('lock');
          if (td.classList.contains('editable')) td.setAttribute('contenteditable','false');
          const inp = td.querySelector('input');
          if (inp) inp.disabled = true;
        });
      }else{
        tr.classList.remove('lockedRow');
        if (tr.dataset) delete tr.dataset.locked;
        toLock.forEach(td => {
          td.classList.remove('lock');
          if (td.classList.contains('editable')) td.setAttribute('contenteditable','true');
          const inp = td.querySelector('input');
          if (inp) inp.disabled = false;
        });
      }
    });
  });
}

function addReservedRow(){
  state.rez = state.rez || [];
  state.rez.push({marcaj:"", dim:"", grade:"", sarja:"", reper:""});
  scheduleRender();
  scheduleAutosave();
  const wr = document.getElementById('wrapRez');
  if (wr) wr.scrollTop = wr.scrollHeight;
}

function deleteReservedRow(idx){
  if (!confirm("»òtergi codul rezervat selectat?")) return;
  if (!Array.isArray(state.rez)) state.rez = [];
  state.rez.splice(idx, 1);
  scheduleRender();
  scheduleAutosave();
}


/* ====== EVENTS (delegate) ====== */
const rootWrap = document;

rootWrap.addEventListener('keydown', (e) => {
  const t = e.target;
  if (!t) return;
  if ((t.matches('td.editable[contenteditable="true"]') || t.matches('td.dropdown input')) && e.key === 'Enter'){
    e.preventDefault();
    t.blur();
  }
}, true);

let _renderQueued = false;
function scheduleRender(){
  if (_renderQueued) return;
  _renderQueued = true;
  setTimeout(() => {
    _renderQueued = false;
    try{ render(); }catch(e){}
  }, 0);
}

let _applyLocksQueued = false;
function scheduleApplyLocks(){
  if (_applyLocksQueued) return;
  _applyLocksQueued = true;
  setTimeout(() => {
    _applyLocksQueued = false;
    try{ applyReservedLocksDom(); }catch(e){}
  }, 0);
}

function commitFromTarget(t, evType){
  if (!t) return;

  // dacƒÉ r√¢ndul este blocat (cod rezervat), ignorƒÉ complet editarea
  const tr = t.closest && t.closest('tr');
  if (tr && tr.dataset && tr.dataset.locked === "1") return;

  // ===== NUMERALKOD REZERVAT =====
  if (t.matches('td.editable[contenteditable="true"][data-rez="1"]')){
    // evitƒÉ re-render pe input; commit doar la ie»ôirea din celulƒÉ
    if (evType !== 'focusout') return;

    const idx = Number(t.dataset.i);
    const field = t.dataset.field;
    if (!Array.isArray(state.rez) || !state.rez[idx]) return;

    const prev = (state.rez[idx][field] || "");
    let val = (t.textContent || "").trim();

    if (field === "marcaj"){
      val = normalizeMarcaj(val);
      const v = validateMarcaj(val);
      if (!v.ok){
        showMsg(v.err);
        t.textContent = normalizeMarcaj(prev);
        return;
      }
      const dup = (state.rez || []).some((x,j) => j !== idx && normalizeMarcaj(x.marcaj) === v.code);
      if (dup){
        showMsg(`Codul ${v.code} existƒÉ deja √Æn tabelul NUMERALKOD rezervat.`);
        t.textContent = normalizeMarcaj(prev);
        return;
      }
      state.rez[idx].marcaj = v.code;
      t.textContent = v.code;

      scheduleAutosave();
      scheduleApplyLocks(); // fƒÉrƒÉ render (nu mai rupe DOM √Æn blur)
      return;
    }

    state.rez[idx][field] = val;
    scheduleAutosave();
    return;
  }

  if (t.matches('td.dropdown input')){
    const td = t.closest('td.dropdown');
    if (!td) return;

    // rezervat?
    if (td.dataset && td.dataset.rez === "1"){
      if (evType !== 'focusout') return; // commit doar la blur
      const idx = Number(td.dataset.i);
      const field = (td.dataset.field || "grade");
      if (!Array.isArray(state.rez) || !state.rez[idx]) return;
      state.rez[idx][field] = (t.value || "").trim();
      scheduleAutosave();
      return;
    }

    // grade input (zale/alte) ‚Äì ignorƒÉ dacƒÉ e disabled
    if (t.disabled) return;

    const group = td.dataset.group;
    const s = Number(td.dataset.s);
    const r = Number(td.dataset.r);
    if (!state[group] || !state[group][s] || !state[group][s].rows[r]) return;
    state[group][s].rows[r].grade = (t.value || "").trim();
    scheduleAutosave();
    return;
  }

  // ===== ZALE / ALTE (text editable) =====
  if (t.matches('td.editable[contenteditable="true"]')){
    const group = t.dataset.group;
    const s = Number(t.dataset.s);
    const r = Number(t.dataset.r);
    const field = t.dataset.field;
    if (!state[group] || !state[group][s] || !state[group][s].rows[r]) return;
    state[group][s].rows[r][field] = (t.textContent || "").trim();
    scheduleAutosave();
    return;
  }
}

rootWrap.addEventListener('input', (e) => commitFromTarget(e.target, 'input'), true);
rootWrap.addEventListener('focusout', (e) => commitFromTarget(e.target, 'focusout'), true);

/* ====== ADD / RESET ====== */
function addSeriesPrompt(group){
  const input = prompt("Introdu SERIA (ex: N5, D10, M5). Litera trebuie sƒÉ fie din N U M E R A L K O D, iar numƒÉrul 1‚Ä¶10.");
  if (!input) return;
  const series = normalizeSeries(input);
  const v = validateSeries(series);
  if (!v.ok){
    showMsg(v.err);
    return;
  }
  const other = (group === 'zale') ? 'alte' : 'zale';
  if (hasSeries(group, series)){
    showMsg(`Seria ${series} existƒÉ deja √Æn tabelul NUMERALKOD ${group === 'zale' ? 'zale' : 'alte repere'}.`);
    return;
  }
  if (hasSeries(other, series)){
    showMsg(`Seria ${series} existƒÉ deja √Æn tabelul NUMERALKOD ${other === 'zale' ? 'zale' : 'alte repere'}.`);
    return;
  }
  // avertizare: dacƒÉ seria genereazƒÉ coduri rezervate, acele r√¢nduri vor fi blocate automat
  const hits = reservedForSeries(series);
  if (hits.length){
    const ok = confirm("Aten»õie: seria " + series + " genereazƒÉ coduri rezervate: " + hits.join(", ") +
      "\nR√¢ndurile respective vor fi colorate »ôi blocate √Æn tabel.\n\nContinui?");
    if (!ok) return;
  }

  state[group].push(makeSeriesObj(series));
  renderGroup(group);
  adjustVisibleRows();
  scheduleAutosave();
  // scroll down to bottom in that table
  const w = document.getElementById(group === 'zale' ? 'wrapZale' : 'wrapAlte');
  w.scrollTop = w.scrollHeight;
}

function resetAll(){
  state = { zale: [makeSeriesObj("N1")], alte: [], rez: [] };
  render();
  scheduleAutosave();
}

/* ====== AUTO-SAVE ====== */
function collectData(){
  const tables = [];
  for (const g of ['zale','alte']){
    state[g].forEach(s => {
      tables.push({ group:g, series:s.series, rows: s.rows.map(r => ({...r})) });
    });
  }
  return tables;
}

function autoSaveNow(){
  if (!CAN_AUTOSAVE) return;
  try{
    const payload = {
      app:"NUMERALKOD",
      version:2,
      savedAt: new Date().toISOString(),
      tables: collectData(),
      reserved: (state.rez || []).map(r => ({
        marcaj: normalizeMarcaj(r.marcaj),
        dim: (r.dim||"").toString(),
        grade: (r.grade||"").toString(),
        sarja: (r.sarja||"").toString(),
        reper: (r.reper||"").toString()
      }))
    };
    localStorage.setItem(AUTO_KEY, JSON.stringify(payload));
}catch(e){}
}


/* ====== CLOUD: salvare manualƒÉ ====== */
function cloudPayloadNow(){
  return {
    app:"NUMERALKOD",
    version:2,
    savedAt: new Date().toISOString(),
    tables: collectData(),
    reserved: (state.rez || []).map(r => ({
      marcaj: normalizeMarcaj(r.marcaj),
      dim: (r.dim||"").toString(),
      grade: (r.grade||"").toString(),
      sarja: (r.sarja||"").toString(),
      reper: (r.reper||"").toString()
    }))
  };
}

async function cloudSaveNow(){
  try{
    if(!window.__rfCloud || typeof window.__rfCloud.push !== "function"){
      showMsg("Cloud: nu este ini»õializat (supabase).");
      return;
    }
    const role = window.__rfCloud.role || "viewer";
    if(role !== "admin" && role !== "editor"){
      showMsg("Nu ai drept de scriere (viewer).");
      return;
    }
    const payload = cloudPayloadNow();
    // apelƒÉm push() o singurƒÉ datƒÉ, fƒÉrƒÉ autosync
    window.__rfCloud.push(payload);
    const badge = document.getElementById("cloudBadge");
    if(badge){ badge.classList.add("ok"); badge.textContent = "Cloud: salvat (manual)"; }
    showMsg("Salvat √Æn cloud.");
  }catch(e){
    console.error(e);
    const badge = document.getElementById("cloudBadge");
    if(badge){ badge.classList.remove("ok"); badge.textContent = "Cloud: eroare"; }
    showMsg("Eroare la salvare √Æn cloud: " + (e?.message || e));
  }
}

async function cloudPullNow(){
  try{
    if(!window.__rfCloud || typeof window.__rfCloud.pull !== "function"){
      showMsg("Cloud: nu este ini»õializat (supabase).");
      return;
    }
    const badge = document.getElementById("cloudBadge");
    if(badge){ badge.classList.remove("ok"); badge.textContent = "Cloud: √Æncarc‚Ä¶"; }

    // Pull from cloud and apply
    const doc = await window.__rfCloud.pull();
    if(doc && doc.tables){
      // apply data using existing import/apply functions if present
      if(typeof applyData === "function"){
        applyData(doc.tables);
      }else if(typeof importData === "function"){
        importData(doc.tables);
      }else if(typeof setDataFromCloud === "function"){
        setDataFromCloud(doc.tables);
      }else{
        // fallback: try to set global state if exists
        if(window.state){
          window.state = doc.tables;
        }
      }
    }

    if(badge){ badge.classList.add("ok"); badge.textContent = "Cloud: √ÆncƒÉrcat"; }
    showMsg("√éncƒÉrcat din cloud.");
  }catch(e){
    console.error(e);
    const badge = document.getElementById("cloudBadge");
    if(badge){ badge.classList.remove("ok"); badge.textContent = "Cloud: eroare"; }
    showMsg("Eroare la √ÆncƒÉrcare din cloud: " + (e?.message || e));
  }
}


let _saveTimer = null;
function scheduleAutosave(){
  if (!CAN_AUTOSAVE) return;
  clearTimeout(_saveTimer);
  _saveTimer = setTimeout(autoSaveNow, 200);
}

function applyDataTables(tables){
  state = {zale:[], alte:[], rez: (state.rez || [])};
  const arr = Array.isArray(tables) ? tables : [];
  arr.forEach(t => {
    const g = (t && t.group === 'alte') ? 'alte' : 'zale'; // default zale for old data
    const series = normalizeSeries(t.series);
    if (!series) return;
    const obj = makeSeriesObj(series);
    const rows = Array.isArray(t.rows) ? t.rows : [];
    for (let i=0;i<Math.min(10, rows.length);i++){
      const r = rows[i] || {};
      obj.rows[i].dim = (r.dim || "").toString();
      obj.rows[i].grade = (r.grade || "").toString();
      obj.rows[i].sarja = (r.sarja || "").toString();
      obj.rows[i].scurt = (r.scurt || "").toString();
    }
    // prevent duplicates on load: first one wins
    if (!findGroupOfSeries(obj.series)) state[g].push(obj);
  });
  if (!state.zale.length) state.zale.push(makeSeriesObj("N1"));
  render();
}

function autoLoad(){
  if (!CAN_AUTOSAVE) return false;
  try{
    const raw = localStorage.getItem(AUTO_KEY);
    if (!raw) return false;
    const obj = JSON.parse(raw);
    if (!obj || !Array.isArray(obj.tables)) return false;
    applyDataTables(obj.tables);
    // rezervat (compatibilitate: poate lipsi)
    if (Array.isArray(obj.reserved)){
      state.rez = obj.reserved.map(x => ({
        marcaj: normalizeMarcaj(x.marcaj),
        dim: (x.dim||"").toString(),
        grade: (x.grade||"").toString(),
        sarja: (x.sarja||"").toString(),
        reper: (x.reper||"").toString()
      })).filter(x => !!x.marcaj);
    }else{
      state.rez = state.rez || [];
    }
    render();
    return true;
  }catch(e){ return false; }
}

function clearAutosave(){
  if (!CAN_AUTOSAVE) return;
  if (!confirm("»òtergi datele salvate automat pentru NUMERALKOD?")) return;
  localStorage.removeItem(AUTO_KEY);
  resetAll();
}

/* ====== FIX: 10 r√¢nduri vizibile √Æn fiecare tabel ====== */
function adjustVisibleRows(){
  const tz = document.getElementById('tblZale');
  if (!tz) return;

  const th = tz.querySelector('thead tr');
  const tr = tz.querySelector('tbody tr');

  // IMPORTANT: c√¢nd iframe-ul e ascuns (display:none), getBoundingClientRect() poate da 0.
  let headH = th ? th.getBoundingClientRect().height : 26;
  let rowH  = tr ? tr.getBoundingClientRect().height : 26;
  if (!headH || headH < 10) headH = 32;
  if (!rowH  || rowH  < 10) rowH  = 26;

  const target = Math.ceil(headH + rowH * 10 + 6);
  const wz = document.getElementById('wrapZale');
  const wa = document.getElementById('wrapAlte');
  if (wz) wz.style.height = target + "px";
  if (wa) wa.style.height = target + "px";

  // rezervat: aceea»ôi √ÆnƒÉl»õime ca tabelele de sus
  const wr = document.getElementById('wrapRez');
  if (wr) wr.style.height = target + "px";
}
window.addEventListener('resize', () => setTimeout(adjustVisibleRows, 50));

// RecalculeazƒÉ c√¢nd pagina devine vizibilƒÉ (switch tab-uri din bara de sus)
window.addEventListener('message', (ev) => {
  if (!ev || !ev.data) return;
  if (ev.data.type === "PAGE_SHOWN"){
    // 2 √ÆncercƒÉri: imediat + dupƒÉ layout
    setTimeout(() => { try{ render(); }catch(e){} try{ adjustVisibleRows(); }catch(e){} }, 40);
    setTimeout(() => { try{ adjustVisibleRows(); }catch(e){} }, 220);
  }
});
/* ====== IMPORT / EXPORT EXCEL (.xlsx) ====== */
function loadScriptOnce(src){
  return new Promise((resolve, reject) => {
    const exists = Array.from(document.querySelectorAll("script")).some(s => s.src && s.src.includes(src));
    if (exists) return resolve();
    const s = document.createElement("script");
    s.src = src;
    s.async = true;
    s.onload = () => resolve();
    s.onerror = () => reject(new Error("Nu pot √ÆncƒÉrca script: " + src));
    document.head.appendChild(s);
  });
}

async function ensureXLSX(){
  if (window.XLSX) return true;

  // 1) local (pune xlsx.full.min.js l√¢ngƒÉ HTML-ul principal)
  try{
    const base = (parent.location.href.split("#")[0].split("?")[0]);
    await loadScriptOnce(new URL("xlsx.full.min.js", base).href);
    if (window.XLSX) return true;
  }catch(e){ /* ignore */ }

  // 2) CDN (dacƒÉ ai internet)
  try{
    await loadScriptOnce("https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js");
    if (window.XLSX) return true;
  }catch(e){ /* ignore */ }

  alert("Nu pot √ÆncƒÉrca librƒÉria XLSX. Solu»õie offline: descarcƒÉ 'xlsx.full.min.js' (SheetJS) »ôi pune-l √Æn acela»ôi folder cu HTML-ul, apoi re√ÆncarcƒÉ.");
  return false;
}

function normalizeHeader(h){
  let s = (h ?? "")
    .toString()
    .trim()
    .toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/\s+/g, " ")
    .replace(/[()]/g, "")
    .replace(/[^a-z0-9 +]/g, "");

  // Excel poate adƒÉuga sufixe numerice la antete duplicate (ex: "SERIA8", "NUMAR3", "MARCAJ SARJA9").
  // Pentru antete strict numerice (ex: "14", "25", "36"), pƒÉstrƒÉm prima cifrƒÉ (1/2/3).
  if (/^\d+$/.test(s)) return (s.charAt(0) || "").trim();

  // EliminƒÉ sufixele numerice (ex: "seria8" -> "seria")
  s = s.replace(/\d+$/g, "").trim();
  return s;
}
function asText(v){
  if (v === null || v === undefined) return "";
  return v.toString().trim();
}

function buildTableAoA(group){
  // 1 sheet / 1 tabel (u»ôor de importat)
  const headers = ["NUMAR","1","2","3","NUMAR2","SERIA","MARCAJ SARJA","DIMENSIUNE MATERIAL","CALITATE (Grade)","SARJA OTEL","COD SCURT"];
  const aoa = [headers];
  const list = state[group] || [];
  list.forEach(serieObj => {
    const series = serieObj.series;
    const pref = prefixFor(series);
    serieObj.rows.forEach((row, idx) => {
      const third = LETTERS[idx];
      const marcaj = pref + third;
      aoa.push([
        idx+1,
        third, third, third,
        idx+1,
        series,
        marcaj,
        row.dim || "",
        row.grade || "",
        row.sarja || "",
        row.scurt || ""
      ]);
    });
  });
  return aoa;
}

function buildCombinedAoA(){
  // 1 sheet cu 2 tabele (ca √Æn Excel-ul tƒÉu, doar cƒÉ include COD SCURT »ôi la ZALE)
  const leftHdr = ["NUMAR","1","2","3","NUMAR2","SERIA","MARCAJ SARJA","DIMENSIUNE MATERIAL","CALITATE (Grade)","SARJA OTEL","COD SCURT"];
  const rightHdr = ["NUMAR","1","2","3","NUMAR2","SERIA","MARCAJ SARJA","DIMENSIUNE MATERIAL","CALITATE (Grade)","SARJA OTEL","COD SCURT"];

  const left = buildTableAoA("zale").slice(1);  // fƒÉrƒÉ header
  const right = buildTableAoA("alte").slice(1);

  const pad2 = ["",""];
  const spacer = [""];
  const aoa = [];

  // titluri
  const row1 = pad2.concat(["NUMERALKOD ZALE"]).concat(Array(leftHdr.length-1).fill("")).concat(spacer).concat(["NUMERALKOD ALTE REPERE"]).concat(Array(rightHdr.length-1).fill(""));
  aoa.push(row1);

  // headere
  aoa.push(pad2.concat(leftHdr).concat(spacer).concat(rightHdr));

  // r√¢nduri
  const maxRows = Math.max(left.length, right.length);
  for (let i=0;i<maxRows;i++){
    const l = left[i] || Array(leftHdr.length).fill("");
    const r = right[i] || Array(rightHdr.length).fill("");
    aoa.push(pad2.concat(l).concat(spacer).concat(r));
  }
  return aoa;
}


function buildReservedAoA(){
  const hdr = ["MARCAJ SARJA","DIMENSIUNE MATERIAL","CALITATE (Grade)","SARJA OTEL","REPER rezervat"];
  const out = [hdr];
  (state.rez || []).forEach(r => {
    const code = normalizeMarcaj(r.marcaj);
    if (!code) return;
    out.push([
      code,
      asText(r.dim),
      asText(r.grade),
      asText(r.sarja),
      asText(r.reper)
    ]);
  });
  return out;
}


function exportXLSX(mode){
  ensureXLSX().then(ok => {
    if (!ok) return;

    const wb = XLSX.utils.book_new();
    const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");

    if (mode === "rez"){
      const ws = XLSX.utils.aoa_to_sheet(buildReservedAoA());
      XLSX.utils.book_append_sheet(wb, ws, "NUMERALKOD_REZERVAT");
      XLSX.writeFile(wb, `NUMERALKOD_REZERVAT_${stamp}.xlsx`);
      return;
    }

    if (mode === "zale" || mode === "alte"){
      const aoa = buildTableAoA(mode);
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      XLSX.utils.book_append_sheet(wb, ws, mode === "zale" ? "NUMERALKOD_ZALE" : "NUMERALKOD_ALTE");
      XLSX.writeFile(wb, `NUMERALKOD_${mode.toUpperCase()}_${stamp}.xlsx`);
      return;
    }

    // all
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildTableAoA("zale")), "NUMERALKOD_ZALE");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildTableAoA("alte")), "NUMERALKOD_ALTE");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildReservedAoA()), "NUMERALKOD_REZERVAT");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildCombinedAoA()), "Sheet1");
    XLSX.writeFile(wb, `NUMERALKOD_ALL_${stamp}.xlsx`);
  });
}

let _importMode = "all";
function importXLSX(mode){
  _importMode = mode || "all";
  const input = document.getElementById("fileImportXLSX");
  if (!input) return;
  input.click();
}

function parseSingleTableAoA(aoa){
  const hdrRow = aoa.findIndex(r => Array.isArray(r)
    && r.some(c => normalizeHeader(c) === "numar")
    && (r.some(c => normalizeHeader(c) === "seria") || r.some(c => normalizeHeader(c).includes("marcaj sarja")))
  );
  if (hdrRow < 0) return {ok:false, err:"Nu gƒÉsesc antetul tabelului (NUMAR / SERIA) √Æn fi»ôier."};

  const hdr = aoa[hdrRow] || [];
  const norm = hdr.map(normalizeHeader);

  const colNumar = norm.findIndex(x => x === "numar");
  const colSeria = norm.findIndex(x => x === "seria");
  const colMarcaj = norm.findIndex(x => x.includes("marcaj sarja"));
  const colDim = norm.findIndex(x => x.includes("dimensiune material"));
  const colCal = norm.findIndex(x => x.startsWith("calitate"));
  const colSarja = norm.findIndex(x => x.includes("sarja otel"));
  const colScurt = norm.findIndex(x => x.includes("cod scurt"));

  if (colNumar < 0) return {ok:false, err:"Antet incomplet: lipse»ôte NUMAR."};
  if (colSeria < 0 && colMarcaj < 0) return {ok:false, err:"Antet incomplet: lipse»ôte SERIA »ôi MARCAJ SARJA (nu pot deduce seria)."};

  const order = [];
  const map = {};

  for (let i=hdrRow+1; i<aoa.length; i++){
    const row = aoa[i] || [];
    let series = (colSeria >= 0) ? normalizeSeries(row[colSeria]) : "";
    if (!series){
      const code = (colMarcaj >= 0) ? normalizeMarcaj(row[colMarcaj]) : "";
      series = inferSeriesFromMarcaj(code);
    }
    if (!series) continue;

    const v = validateSeries(series);
    if (!v.ok) continue;

    const n = Number(asText(row[colNumar]));
    if (!(n>=1 && n<=10)) continue;

    if (!map[series]){
      map[series] = makeSeriesObj(series);
      order.push(series);
    }
    const obj = map[series];
    obj.rows[n-1].dim   = colDim   >= 0 ? asText(row[colDim])   : "";
    obj.rows[n-1].grade = colCal   >= 0 ? asText(row[colCal])   : "";
    obj.rows[n-1].sarja = colSarja >= 0 ? asText(row[colSarja]) : "";
    obj.rows[n-1].scurt = colScurt >= 0 ? asText(row[colScurt]) : "";
  }

  return {ok:true, list: order.map(s => map[s])};
}

function parseSideBySideAoA(aoa){
  // cautƒÉ un r√¢nd cu douƒÉ antete NUMAR (st√¢nga + dreapta)
  const hdrRow = aoa.findIndex(r => {
    if (!Array.isArray(r)) return false;
    const norm = r.map(normalizeHeader);
    const idx = [];
    norm.forEach((x,j)=>{ if (x==="numar") idx.push(j); });
    return idx.length >= 2 && norm.includes("seria");
  });

  if (hdrRow < 0){
    // fallback: trateazƒÉ ca single-table
    const single = parseSingleTableAoA(aoa);
    if (!single.ok) return {ok:false, err: single.err};
    return {ok:true, zale: single.list, alte: []};
  }

  const hdr = aoa[hdrRow] || [];
  const norm = hdr.map(normalizeHeader);
  const numIdxs = [];
  norm.forEach((x,j)=>{ if (x==="numar") numIdxs.push(j); });

  const leftStart = numIdxs[0];
  const rightStart = numIdxs[numIdxs.length-1];

  const leftSeg = hdr.slice(leftStart, rightStart);
  const rightSeg = hdr.slice(rightStart);

  function buildMap(seg, offset){
    const n = seg.map(normalizeHeader);
    const colNumar  = n.findIndex(x=>x==="numar"); if (colNumar>=0) n[colNumar] = "numar";
    const colSeria  = n.findIndex(x=>x==="seria");
    const colMarcaj = n.findIndex(x=>x.includes("marcaj sarja"));
    const colDim    = n.findIndex(x=>x.includes("dimensiune material"));
    const colCal    = n.findIndex(x=>x.startsWith("calitate"));
    const colSarja  = n.findIndex(x=>x.includes("sarja otel"));
    const colScurt  = n.findIndex(x=>x.includes("cod scurt"));
    return {
      colNumar:  colNumar>=0  ? offset+colNumar  : -1,
      colSeria:  colSeria>=0  ? offset+colSeria  : -1,
      colMarcaj: colMarcaj>=0 ? offset+colMarcaj : -1,
      colDim:    colDim>=0    ? offset+colDim    : -1,
      colCal:    colCal>=0    ? offset+colCal    : -1,
      colSarja:  colSarja>=0  ? offset+colSarja  : -1,
      colScurt:  colScurt>=0  ? offset+colScurt  : -1
    };
  }

  const mapL = buildMap(leftSeg, leftStart);
  const mapR = buildMap(rightSeg, rightStart);

  function parseWithMap(map){
    if (map.colNumar < 0) return [];
    const order = [];
    const dict = {};
    for (let i=hdrRow+1; i<aoa.length; i++){
      const row = aoa[i] || [];
      let series = (map.colSeria >= 0) ? normalizeSeries(row[map.colSeria]) : "";
      if (!series){
        const code = (map.colMarcaj >= 0) ? normalizeMarcaj(row[map.colMarcaj]) : "";
        series = inferSeriesFromMarcaj(code);
      }
      if (!series) continue;
      const v = validateSeries(series);
      if (!v.ok) continue;

      const n = Number(asText(row[map.colNumar]));
      if (!(n>=1 && n<=10)) continue;

      if (!dict[series]){
        dict[series] = makeSeriesObj(series);
        order.push(series);
      }
      const obj = dict[series];
      obj.rows[n-1].dim   = map.colDim   >=0 ? asText(row[map.colDim]) : "";
      obj.rows[n-1].grade = map.colCal   >=0 ? asText(row[map.colCal]) : "";
      obj.rows[n-1].sarja = map.colSarja >=0 ? asText(row[map.colSarja]) : "";
      obj.rows[n-1].scurt = map.colScurt >=0 ? asText(row[map.colScurt]) : "";
    }
    return order.map(s=>dict[s]);
  }

  return {ok:true, zale: parseWithMap(mapL), alte: parseWithMap(mapR)};
}


function parseReservedAoA(aoa){
  const hdrRow = aoa.findIndex(r => Array.isArray(r) && r.some(c => normalizeHeader(c).includes("marcaj sarja")));
  if (hdrRow < 0) return {ok:false, err:"Nu gƒÉsesc antetul pentru NUMERALKOD REZERVAT (MARCAJ SARJA) √Æn fi»ôier."};
  const hdr = aoa[hdrRow] || [];
  const norm = hdr.map(normalizeHeader);

  const colMarcaj = norm.findIndex(x => x.includes("marcaj sarja"));
  const colDim    = norm.findIndex(x => x.includes("dimensiune material"));
  const colCal    = norm.findIndex(x => x.startsWith("calitate"));
  const colSarja  = norm.findIndex(x => x.includes("sarja otel"));
  const colReper  = norm.findIndex(x => x.includes("reper"));

  if (colMarcaj < 0) return {ok:false, err:"Antet incomplet: lipse»ôte MARCAJ SARJA."};

  const list = [];
  const seen = new Set();
  for (let i=hdrRow+1; i<aoa.length; i++){
    const row = aoa[i] || [];
    const codeRaw = asText(row[colMarcaj]);
    if (!codeRaw) continue;
    const v = validateMarcaj(codeRaw);
    if (!v.ok) continue;
    if (seen.has(v.code)) continue;
    seen.add(v.code);
    list.push({
      marcaj: v.code,
      dim: colDim >=0 ? asText(row[colDim]) : "",
      grade: colCal >=0 ? asText(row[colCal]) : "",
      sarja: colSarja >=0 ? asText(row[colSarja]) : "",
      reper: colReper >=0 ? asText(row[colReper]) : ""
    });
  }
  return {ok:true, list};
}


function applyImport(mode, payload){
  const report = {skipped:[], importedZale:0, importedAlte:0, importedRez:0};

  // rezervat (poate veni la orice import)
  if (Array.isArray(payload.rez) || Array.isArray(payload.reserved)){
    const arr = payload.rez || payload.reserved || [];
    const seen = new Set();
    state.rez = arr.map(x => ({
      marcaj: normalizeMarcaj(x.marcaj),
      dim: (x.dim||"").toString(),
      grade: (x.grade||"").toString(),
      sarja: (x.sarja||"").toString(),
      reper: (x.reper||"").toString()
    })).filter(x => {
      if (!x.marcaj) return false;
      if (seen.has(x.marcaj)) return false;
      seen.add(x.marcaj);
      return true;
    });
    report.importedRez = state.rez.length;
  }else if (mode === "rez" && Array.isArray(payload.list)){
    // compat: import rezervat ca {list:[...]}
    const seen = new Set();
    state.rez = payload.list.map(x => ({
      marcaj: normalizeMarcaj(x.marcaj),
      dim: (x.dim||"").toString(),
      grade: (x.grade||"").toString(),
      sarja: (x.sarja||"").toString(),
      reper: (x.reper||"").toString()
    })).filter(x => {
      if (!x.marcaj) return false;
      if (seen.has(x.marcaj)) return false;
      seen.add(x.marcaj);
      return true;
    });
    report.importedRez = state.rez.length;
  }

  if (mode === "rez"){
    render();
    scheduleAutosave();
    showMsg(`Import OK. REZERVAT: ${report.importedRez} coduri`);
    return;
  }

  if (mode === "all"){
    const next = {zale:[], alte:[], rez: state.rez || []};

    (payload.zale || []).forEach(obj=>{
      if (next.zale.some(x=>x.series===obj.series)) return;
      next.zale.push(obj);
    });
    // ALTE: import fidel (permite serii duplicate √Æntre ZALE »ôi ALTE)
    (payload.alte || []).forEach(obj=>{
      if (next.alte.some(x=>x.series===obj.series)) return;
      next.alte.push(obj);
    });

    if (!next.zale.length) next.zale.push(makeSeriesObj("N1"));
    state = next;
    report.importedZale = next.zale.length;
    report.importedAlte = next.alte.length;

  }else if (mode === "zale" || mode === "alte"){
    const other = mode === "zale" ? "alte" : "zale";
    const incoming = payload[mode] || payload.list || [];
    // Import fidel: nu blocheazƒÉ duplicatele fa»õƒÉ de celƒÉlalt tabel.
    const incomingClean = [];
    (incoming || []).forEach(obj=>{
      if (!obj || !obj.series) return;
      if (incomingClean.some(x=>x.series===obj.series)) return; // pƒÉstrƒÉm unicitatea internƒÉ
      incomingClean.push(obj);
    });
    state[mode] = incomingClean.length ? incomingClean : (mode==="zale" ? [makeSeriesObj("N1")] : []);
    report.importedZale = state.zale.length;
    report.importedAlte = state.alte.length;
  }

  render();
  scheduleAutosave();

  const msgParts = [];
  msgParts.push(`Import OK. ZALE: ${report.importedZale} serii | ALTE: ${report.importedAlte} serii | REZERVAT: ${report.importedRez} coduri`);
  if (report.skipped.length){
    msgParts.push("Ignorate (duplicate √Æn celƒÉlalt tabel): " + report.skipped.join(", "));
  }
  showMsg(msgParts.join("\n"));
}

(function wireImportXLSX(){
  const input = document.getElementById("fileImportXLSX");
  if (!input) return;

  input.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    try{
      const ok = await ensureXLSX();
      if (!ok) return;

      const buf = await f.arrayBuffer();
      const wb = XLSX.read(buf, {type:"array"});

      const nameZ = wb.SheetNames.find(n => normalizeHeader(n).includes("zale"));
      const nameA = wb.SheetNames.find(n => normalizeHeader(n).includes("alte"));
      const nameR = wb.SheetNames.find(n => normalizeHeader(n).includes("rezerv"));

      let payload = {zale:[], alte:[], rez:[]};

      if ((_importMode === "zale" || _importMode === "all") && nameZ){
        const aoa = XLSX.utils.sheet_to_json(wb.Sheets[nameZ], {header:1, raw:false, defval:""});
        const parsed = parseSingleTableAoA(aoa);
        if (parsed.ok) payload.zale = parsed.list;
      }
      if ((_importMode === "alte" || _importMode === "all") && nameA){
        const aoa = XLSX.utils.sheet_to_json(wb.Sheets[nameA], {header:1, raw:false, defval:""});
        const parsed = parseSingleTableAoA(aoa);
        if (parsed.ok) payload.alte = parsed.list;
      }
      if ((_importMode === "rez" || _importMode === "all") && nameR){
        const aoa = XLSX.utils.sheet_to_json(wb.Sheets[nameR], {header:1, raw:false, defval:""});
        const parsed = parseReservedAoA(aoa);
        if (parsed.ok) payload.rez = parsed.list;
      }

      // fallback: sheet1 side-by-side (zale/alte)
      if ((_importMode === "zale" || _importMode === "alte" || _importMode === "all") && !payload.zale.length && !payload.alte.length){
        const firstName = wb.SheetNames[0];
        const aoa = XLSX.utils.sheet_to_json(wb.Sheets[firstName], {header:1, raw:false, defval:""});
        const parsed = parseSideBySideAoA(aoa);
        if (parsed.ok){
          payload.zale = parsed.zale || [];
          payload.alte = parsed.alte || [];

          // DacƒÉ utilizatorul importƒÉ doar ALTE/Zale dintr-un Excel care con»õine un singur tabel
          // (fƒÉrƒÉ douƒÉ tabele side-by-side »ôi fƒÉrƒÉ sheet dedicat), parseSideBySideAoA √Æl trateazƒÉ ca "single-table"
          // »ôi √Æl pune √Æn `zale`. √én modul "alte" trebuie sƒÉ √Æl mapƒÉm √Æn `alte`.
          if (_importMode === "alte" && !payload.alte.length && payload.zale.length){
            payload.alte = payload.zale;
            payload.zale = [];
          }
          if (_importMode === "zale" && !payload.zale.length && payload.alte.length){
            payload.zale = payload.alte;
            payload.alte = [];
          }
        }
      }

      // fallback rezervat: prima foaie
      if (_importMode === "rez" && !payload.rez.length){
        const firstName = wb.SheetNames[0];
        const aoa = XLSX.utils.sheet_to_json(wb.Sheets[firstName], {header:1, raw:false, defval:""});
        const parsed = parseReservedAoA(aoa);
        if (!parsed.ok) throw new Error(parsed.err || "Import REZERVAT e»ôuat.");
        payload.rez = parsed.list || [];
      }

      if (_importMode === "zale"){
        applyImport("zale", {zale: payload.zale});
      }else if (_importMode === "alte"){
        applyImport("alte", {alte: payload.alte});
      }else if (_importMode === "rez"){
        applyImport("rez", {rez: payload.rez});
      }else{
        applyImport("all", payload);
      }

    }catch(err){
      alert("Nu am putut importa Excel: " + (err?.message || err));
    }finally{
      e.target.value = "";
    }
  });
})();


/* ====== HELPER (source of truth) ====== */
const HELPERS_KEY = "RF_HELPERS_v1";
function getHelpersSafe(){
  try{ return JSON.parse(localStorage.getItem(HELPERS_KEY) || "{}") || {}; }catch(e){ return {}; }
}
function setDatalistOptions(id, values){
  const dl = document.getElementById(id);
  if (!dl) return;
  const seen = new Set();
  const opts = [];
  (values || []).forEach(v => {
    const s = (v ?? "").toString().trim();
    if (!s || seen.has(s)) return;
    seen.add(s);
    opts.push(`<option value="${escapeAttr(s)}"></option>`);
  });
  dl.innerHTML = opts.join("");
}
function refreshHelperDatalists(){
  const h = getHelpersSafe();

  const repereForjate = Array.isArray(h.repere_forjate) ? h.repere_forjate
    .map(o => o?.REPER_FORJAT ?? o?.Reper ?? o?.REPER)
    .filter(Boolean) : [];
  setDatalistOptions("forjateList", repereForjate);

  if (Array.isArray(h.lista_calitati) && h.lista_calitati.length){
    setDatalistOptions("gradeList", h.lista_calitati);
  }
}
window.addEventListener("message", (e) => {
  if (e && e.data && e.data.type === "HELPERS_UPDATED"){
    refreshHelperDatalists();
  }
});


/* ====== INIT ====== */

// ===== CLOUD APPLY HOOK =====
window.applyCloudPayload = function(payload){
  try{
    // payload: {app, version, tables, reserved}
    if(!payload) return;
    if(Array.isArray(payload.tables)) applyDataTables(payload.tables);
    if(Array.isArray(payload.reserved)){
      const seen = new Set();
      state.rez = payload.reserved.map(x=>({
        marcaj: normalizeMarcaj(x.marcaj),
        dim: (x.dim||"").toString(),
        grade: (x.grade||"").toString(),
        sarja: (x.sarja||"").toString(),
        reper: (x.reper||"").toString()
      })).filter(x=>{
        if(!x.marcaj) return false;
        if(seen.has(x.marcaj)) return false;
        seen.add(x.marcaj);
        return true;
      });
    }
    render();
  }catch(e){ console.error(e); }
};

(function init(){
  state.zale = [makeSeriesObj("N1")];
  state.alte = [];
  state.rez = [];
  render();
  autoLoad();
  try{ refreshHelperDatalists(); }catch(e){}
})();
</script>

<script>
/* ===============================
   RF LIVE CLOUD (rf_documents)
   - √énlocuie»ôte "localStorage-only" cu cloud + realtime
   =============================== */
(function(){
 const SUPABASE_URL = "https://rhjcnydkdhjzazygybcc.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJoamNueWRrZGhqemF6eWd5YmNjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE4ODEzMzYsImV4cCI6MjA4NzQ1NzMzNn0.ompOZWqnFGsnOQzPiAv2QBwuaNiKtnz5PciRwCWh0Hk"; // <-- Anon Key (Legacy)
;
  const DOC_TABLE = "rf_documents";
  const DOC_KEY = "numeralkod";   // un singur document global pentru NUMERALKOD
  const CHANNEL = "rf_docs_numeralkod";

  function nowIso(){ return new Date().toISOString(); }

  // creeazƒÉ client
  const supa = (window.supabase && window.supabase.createClient)
    ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
    : null;

  let role = "viewer";
  let user = null;
  let ready = false;
  let applyingRemote = false;
  let lastPushedAt = 0;

  function setBadge(ok, msg){
    const el = document.getElementById("cloudBadge");
    if(!el) return;
    el.classList.toggle("ok", !!ok);
    el.textContent = msg || (ok ? "Cloud: ON" : "Cloud: eroare");
  }

  async function detectRole(){
    try{
      const { data: sess } = await supa.auth.getSession();
      user = sess && sess.session && sess.session.user ? sess.session.user : null;
      if(!user){ role = "viewer"; return; }
      const { data, error } = await supa.from("profiles").select("role").eq("id", user.id).maybeSingle();
      if(error) throw error;
      role = (data && data.role) ? data.role : "viewer";
    }catch(e){
      role = "viewer";
    }
  }

  async function pull(){
    const { data, error } = await supa.from(DOC_TABLE).select("doc_key,data,updated_at").eq("doc_key", DOC_KEY).maybeSingle();
    if(error) throw error;
    if(data && data.data){
      applyingRemote = true;
      try{
        // data.data este exact payload-ul autosave (app/version/tables/reserved)
        if (typeof window.applyCloudPayload === "function") window.applyCloudPayload(data.data);
      } finally {
        applyingRemote = false;
      }
    }
  }

  let pushTimer = null;
  async function push(payload){
    if(!supa) return;
    if(applyingRemote) return;
    if(role !== "admin" && role !== "editor") return; // viewer nu scrie
    // debounce
    clearTimeout(pushTimer);
    pushTimer = setTimeout(async ()=>{
      try{
        const ts = Date.now();
        // protec»õie anti spam
        if(ts - lastPushedAt < 350) return;
        lastPushedAt = ts;
        const up = {
          doc_key: DOC_KEY,
          data: payload,
          updated_at: nowIso()
        };
        const { error } = await supa.from(DOC_TABLE).upsert(up, { onConflict: "doc_key" });
        if(error) throw error;
        setBadge(true, "Cloud: ON");
      }catch(e){
        console.error(e);
        setBadge(false, "Cloud: eroare");
      }
    }, 500);
  }

  function subscribe(){ /* realtime disabled (manual cloud mode) */ }

  async function boot(){
    if(!supa){
      setBadge(false, "Cloud: lipsƒÉ supabase-js");
      return;
    }
    setBadge(false, "Cloud: conectare...");
    await detectRole();
    try{
      await pull();
      // realtime disabled
ready = true;
      setBadge(true, "Cloud: ON");
    }catch(e){
      console.error(e);
      setBadge(false, "Cloud: eroare");
    }
  }

  // expunem pentru scriptul principal
  window.__rfCloud = { push, pull, get role(){return role;}, get user(){return user;} };

  // porne»ôte imediat
  boot();
})();


</script>



<script>
/* v2.7 mobile fix: stack NUMERALKOD tables vertically and add horizontal scroll wrappers */
(function(){
  function wrapTable(table){
    if(!table || table.closest('.rf-mobile-scroll')) return;
    const w = document.createElement('div');
    w.className = 'rf-mobile-scroll';
    w.style.overflowX = 'auto';
    w.style.webkitOverflowScrolling = 'touch';
    w.style.width = '100%';
    table.parentNode.insertBefore(w, table);
    w.appendChild(table);
  }

  function applyNumeralkodMobileLayout(){
    const isMobile = window.matchMedia('(max-width: 980px)').matches;

    // find the two main cards by headings text
    const cards = [...document.querySelectorAll('div,section,article')].filter(el=>{
      const t = (el.textContent || '').trim();
      return t.includes('NUMERALKOD zale') || t.includes('NUMERALKOD alte repere');
    });

    // stack nearest common container if two cards found
    if(cards.length >= 2){
      const c1 = cards.find(c => (c.textContent||'').includes('NUMERALKOD zale'));
      const c2 = cards.find(c => (c.textContent||'').includes('NUMERALKOD alte repere'));
      if(c1 && c2){
        // choose top-level visual card containers (not tiny inner nodes)
        const pickCard = (node)=>{
          let cur = node;
          for(let i=0;i<6 && cur; i++, cur=cur.parentElement){
            const style = cur ? getComputedStyle(cur) : null;
            if(cur && style && (style.borderRadius !== '0px' || style.boxShadow !== 'none' || style.border !== '0px none rgb(0, 0, 0)')){
              return cur;
            }
          }
          return node;
        };
        const card1 = pickCard(c1), card2 = pickCard(c2);
        if(card1 && card2 && card1 !== card2){
          const parent = card1.parentElement;
          if(parent && parent === card2.parentElement){
            if(isMobile){
              parent.style.display = 'block';
              card1.style.width = '100%';
              card2.style.width = '100%';
              card1.style.marginBottom = '12px';
            }
          }
        }
      }
    }

    // wrap all visible tables in scroll containers
    document.querySelectorAll('table').forEach(wrapTable);
  }

  window.addEventListener('load', ()=> setTimeout(applyNumeralkodMobileLayout, 300));
  window.addEventListener('resize', applyNumeralkodMobileLayout);
  setTimeout(applyNumeralkodMobileLayout, 1200);
})();
</script>

<script>
/* ===== Access control (admin/editor/viewer) + AutoScroll (v2.8) ===== */
let RF_ROLE = "viewer";
let RF_USER_EMAIL = "";
const RF_CAN_EXPORT = true;              // viewer poate exporta
const RF_CAN_EDIT_NUMERALKOD = (role)=> role === "admin"; // numeralkod: doar admin editeazƒÉ

async function rfGetRole(){
  try{
    const client = (typeof sb !== "undefined" && sb) ? sb : (window.sb || window.supabaseClient || null);
    if(!client) return { role:"viewer", email:"" };

    const { data: s } = await client.auth.getSession();
    const sess = s?.session;
    if(!sess) return { role:"viewer", email:"" };

    const email = sess.user?.email || "";
    const { data } = await client.from("profiles").select("role").eq("id", sess.user.id).maybeSingle();
    const role = data?.role || "viewer";
    return { role, email };
  }catch(e){
    console.warn("rfGetRole", e);
    return { role:"viewer", email:"" };
  }
}

function rfSetRoleUI(){
  const el = document.getElementById("rfRolePill");
  if(el){
    el.textContent = RF_USER_EMAIL ? `(${RF_USER_EMAIL} ‚Ä¢ ${RF_ROLE})` : `(${RF_ROLE})`;
  }

  const editable = RF_CAN_EDIT_NUMERALKOD(RF_ROLE);

  // Disable write actions if not admin (but keep Export enabled)
  const idsWrite = [
    "btnAddSerieZale", "btnAddSerieAlte", "btnAddSerie",
    "btnImportZale","btnImportAlte","btnImportRezervat",
    "btnResetAll","btnClearAutosave","btnImportExcel","btnImport",
    "btnStergeAutosave","btnReset",
    "btnSave","btnDelete","btnNew"
  ];
  idsWrite.forEach(id=>{
    const b = document.getElementById(id);
    if(b){
      if(!editable){
        b.disabled = true;
        b.title = "Doar admin poate modifica NUMERALKOD.";
        b.style.opacity = "0.6";
        b.style.cursor = "not-allowed";
      }else{
        b.disabled = false;
        b.title = "";
        b.style.opacity = "";
        b.style.cursor = "";
      }
    }
  });

  // Export allowed for all
  const idsExport = ["btnExportExcel","btnExport","btnExportZale","btnExportAlte","btnExportRezervat"];
  idsExport.forEach(id=>{
    const b = document.getElementById(id);
    if(b){
      b.disabled = false;
      b.title = "";
      b.style.opacity = "";
      b.style.cursor = "";
    }
  });
}

/* AutoScroll to bottom for each scrollable table container (on load + after import) */
const rfScrolledOnce = new WeakSet();

function rfAutoScrollBottom(){
  try{
    const candidates = Array.from(document.querySelectorAll("*")).filter(el=>{
      const st = getComputedStyle(el);
      const oy = st.overflowY;
      if(!(oy === "auto" || oy === "scroll")) return false;
      if(el.scrollHeight <= el.clientHeight + 2) return false;
      return !!el.querySelector("table");
    });

    candidates.forEach(el=>{
      if(rfScrolledOnce.has(el)) return;
      el.scrollTop = el.scrollHeight;
      rfScrolledOnce.add(el);
    });
  }catch(e){
    console.warn("rfAutoScrollBottom", e);
  }
}

window.addEventListener("load", ()=>{
  setTimeout(rfAutoScrollBottom, 300);
  setTimeout(rfAutoScrollBottom, 1200);
});

function rfWrapIfExists(fnName){
  const fn = window[fnName];
  if(typeof fn !== "function") return;
  window[fnName] = async function(...args){
    const out = await fn.apply(this, args);
    setTimeout(rfAutoScrollBottom, 200);
    setTimeout(rfAutoScrollBottom, 900);
    return out;
  }
}
["importExcel","handleImportExcel","doImportExcel","importJSON","handleImport"].forEach(rfWrapIfExists);

(async ()=>{
  const r = await rfGetRole();
  RF_ROLE = r.role; RF_USER_EMAIL = r.email;
  rfSetRoleUI();
})();

</script>
</body>
</html>
